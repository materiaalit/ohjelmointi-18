---
  title: Osa 7
  exercise_page: true
  quiz_page: true
  published: true
---


<% partial 'partials/hint', locals: { name: 'Seitsemännen osan tavoitteet' } do %>

  <p>
    Osaa pilkkoa ohjelman useampaan osaan, missä yhden vastuulla on (tekstimuotoinen) käyttöliittymä, toinen vastuulla sovelluslogiikka. Ryhmittelee arvoja hajautustaulun avulla ja osaa käyttää listaa hajautustaulun arvona. Osaa hyödyntää Javan valmiita kirjastoja satunnaisten lukujen luomiseen. Osaa luoda yksinkertaisia simulaatioita. 
  </p>
  
<% end %>

<% partial 'partials/hint', locals: { name: 'Kurssin väli/loppukysely' } do %>

  <p>
    Kurssiin kuuluu kyselyitä, joiden tavoitteena on parantaa kurssia. Vastaa kyselyyn osoitteessa <a href="https://elomake.helsinki.fi/lomakkeet/83363/lomake.html"  target="_blank" rel="noopener">https://elomake.helsinki.fi/lomakkeet/83363/lomake.html</a>.
  </p>

  <p>
    Käy vastaamassa ensin kyselyyn ja ruksaa sen jälkeen allaoleva tekstikenttä. Jos allaolevan tekstikentän ruksaaminen ei onnistu, varmista että olet kirjautunut tälle sivulle. Kirjautuminen onnistuu sivun oikeasta ylälaidasta.
  </p>

  <%= partial 'partials/quiz', locals: { id: '59e4d7099dd6740004efcb54' } %>

<% end %>



<% partial 'partials/exercise', locals: { name: 'Kirjaston tietojärjestelmä (3 osaa)' } do %>

  <p>
    Tässä tehtävässä kerrataan olio-ohjelmoinnin perusteita sekä listojen käsittelyä virran avulla.
  </p>

  <p>
    <em>
      Kumpulan tiedekirjasto tarvitsee uuden järjestelmän kirjojen hallintaan. Tässä tehtävässä hahmotellaan ongelma-alueen tietosisältöä ja toteutetaan prototyyppi, joka mahdollistaa kirjan haun nimen, julkaisijan tai julkaisuvuoden perusteella.
    </em>
  </p>

  <p>
    Rakennetaan järjestelmä osista, ensin toteutetaan oleelliset luokat eli <code>Kirja</code> ja <code>Kirjasto</code>. Luokka <code>Kirja</code> sisältää kirjaan liittyvät tiedot, luokka <code>Kirjasto</code> tarjoaa erilaisia hakutoiminnallisuuksia kirjoihin liittyen.
  </p>

  <h2>Kirja</h2>

  <p>
    Luodaan ensiksi luokka Kirja. Kirjalla on oliomuuttujina <code>nimeke</code>, eli kirjan nimi, <code>julkaisija</code>, eli kirjan julkaisija, ja <code>julkaisuvuosi</code> eli vuosi jolloin kirja on julkaistu. Kaksi ensimmäistä muuttujaa on merkkijonotyyppisiä, viimeisin on kokonaisluku. Oletamme tässä että kirjalla on aina vain yksi kirjoittaja.
  </p>

  <p>
    Toteuta luokka <code>Kirja</code>. Kirjalla tulee olla myös konstruktori <code>public Kirja(String niemeke, String julkaisija, int julkaisuvuosi)</code> sekä metodit <code>public String nimeke()</code>, <code>public String julkaisija()</code>, <code>public int julkaisuvuosi()</code> ja <code>public String toString()</code>. Arvannet mitä metodien tulee tehdä, alla esimerkki.
  </p>

  <p>
    Testaa luokan toimintaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kirja cheese = new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007);
    System.out.println(cheese.nimeke());
    System.out.println(cheese.julkaisija());
    System.out.println(cheese.julkaisuvuosi());

    System.out.println(cheese);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Cheese Problems Solved
    Woodhead Publishing
    2007
    Cheese Problems Solved, Woodhead Publishing, 2007
  <% end %>


  <h2>Kirjasto</h2>

  <p>
    Kirjaston tehtävä on antaa käyttäjälle mahdollisuus kirjojen lisäämiseen ja niiden hakemiseen. Luo luokka <code>Kirjasto</code>, jolla on konstruktori <code>public Kirjasto()</code> ja metodit <code>public void lisaaKirja(Kirja uusiKirja)</code> ja <code>public void tulostaKirjat()</code>
  </p>

  <% partial 'partials/code_highlight' do %>
    Kirjasto kirjasto = new Kirjasto();

    Kirja cheese = new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007);
    kirjasto.lisaaKirja(cheese);

    Kirja nhl = new Kirja("NHL Hockey", "Stanley Kupp", 1952);
    kirjasto.lisaaKirja(nhl);

    kirjasto.lisaaKirja(new Kirja("Battle Axes", "Tom A. Hawk", 1851));

    kirjasto.tulostaKirjat();
  <% end %>

  <% partial 'partials/sample_output' do %>
    Cheese Problems Solved, Woodhead Publishing, 2007
    NHL Hockey, Stanley Kupp, 1952
    Battle Axes, Tom A. Hawk, 1851
  <% end %>


  <h2>Hakutoiminnallisuus</h2>

  <p>
    Kirjastosta tulee pystyä etsimään kirjoja nimekkeiden ja julkaisijoiden perusteella. Lisää kirjastolle metodit <code>public ArrayList&lt;Kirja&gt; haeKirjaNimekkeella(String nimeke)</code>, <code>public ArrayList&lt;Kirja&gt; haeKirjaJulkaisijalla(String julkaisija)</code> ja <code>public ArrayList&lt;Kirja&gt; haeKirjaJulkaisuvuodella(int julkaisuvuosi)</code>. Metodit palauttavat listan kirjoista, joissa on haluttu nimeke, julkaisija tai julkaisuvuosi.
  </p>

  <p>
    Voit halutessasi hyödyntää seuraavaa runkoa metodin tekemiseen.
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Kirjasto {
        // ...

        public ArrayList&lt;Kirja&gt; haeKirjaNimekkeella(String nimeke) {
            ArrayList&lt;Kirja&gt; loydetyt = new ArrayList&lt;&gt;();

            // käy läpi kaikki kirjat ja lisää ne joilla haetun kaltainen nimeke listalle loydetyt

            return loydetyt;
        }
    }
  <% end %>

  <p>
    Huom! Kun haet teet hakua merkkijonon avulla, älä tee tarkkaa hakua (metodi <code>equals</code>) vaan käytä <code>String</code>-luokan metodia <code>contains</code>. Huomaat todennäköisesti myös että sinulla on ns. copy-paste -koodia <code>Kirjasto</code>-luokan koodissa. Keksitkö tavan päästä siitä eroon?
  </p>

  <% partial 'partials/code_highlight' do %>
    Kirjasto kirjasto = new Kirjasto();

    kirjasto.lisaaKirja(new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007));
    kirjasto.lisaaKirja(new Kirja("The Stinky Cheese Man and Other Fairly Stupid Tales", "Penguin Group", 1992));
    kirjasto.lisaaKirja(new Kirja("NHL Hockey", "Stanley Kupp", 1952));
    kirjasto.lisaaKirja(new Kirja("Battle Axes", "Tom A. Hawk", 1851));

    kirjasto.haeKirjaNimekkeella("Cheese").forEach(k -&gt; System.out.println(k));

    System.out.println("---");
    kirjasto.haeKirjaJulkaisijalla("Pong Group").forEach(k -&gt; System.out.println(k));

    System.out.println("---");
    kirjasto.haeKirjaJulkaisuvuodella(1851).forEach(k -&gt; System.out.println(k));
  <% end %>

  <% partial 'partials/sample_output' do %>
    Cheese Problems Solved, Woodhead Publishing, 2007
    The Stinky Cheese Man and Other Fairly Stupid Tales, Penguin Group, 1992
    ---
    ---
    Battle Axes, Tom A. Hawk, 1851
  <% end %>

<% end %>


<% partial 'partials/material_heading' do %>
  Käyttöliittymän ja sovelluslogiikan eriyttäminen
<% end %>

<p>
  Edellisessä osassa tarkasteltiin sovelluksen jakamista vastuualueisiin. Jatketaan tässä samalla teemalla. 
</p>

<p>
  Suurin syy käyttöliittymän ja sovelluslogiikan eriyttämiseen on ohjelman ylläpidettävyyden ja ymmärrettävyyden lisääminen. Sovellluslogiikan eri osa-alueet ovat ideaalitilanteessa käyttöliittymäriippumattomia, jolloin niitä voidaan parannella ilman käyttöliittymään koskemista. Vastaavasti osia voidaan siirtää sovelluksesta toiseen. Vastaavasti käyttöliittymä on vaihdettavissa tekstikäyttöliittymästä graafiseen käyttöliittymään.
</p>

<p>
  Edellä kuvattu tilanne vaatii kuitenkin sen, että ohjelman komponenttien tarjoamat rajapinnat eli metodit ja niiden parametrit on selkeästi määritelty. 
</p>

<p>
  Hahmotellaan Kivi-paper-sakset -peliä sekä siihen liittyvää "tekoälyä". Peli kysyy käyttäjältä siirtoa, kysyy sen jälkeen tietokoneen valintaa ja lopulta kertoo tuloksen. Pelin lopettaminen onnistuu syöttämällä tyhjän merkkijonon.
</p>

<% partial 'partials/sample_output' do %>
  KPS!
  Valitse [k]ivi, [p]aperi tai [s]akset: <font color="red">k</font>
  Tietokone valitsi: k
  Tasapeli.
  Tilanne: Pelaaja 0 - 0 Tietokone

  Valitse [k]ivi, [p]aperi tai [s]akset: <font color="red">p</font>
  Tietokone valitsi: k
  Pelaaja voitti!
  Tilanne: Pelaaja 1 - 0 Tietokone

  Valitse [k]ivi, [p]aperi tai [s]akset: <font color="red">p</font>
  Tietokone valitsi: k
  Pelaaja voitti!
  Tilanne: Pelaaja 2 - 0 Tietokone

  Valitse [k]ivi, [p]aperi tai [s]akset: <font color="red">s</font>
  Tietokone valitsi: k
  Tietokone voitti!
  Tilanne: Pelaaja 2 - 1 Tietokone

  Valitse [k]ivi, [p]aperi tai [s]akset: <font color="red">s</font>
  Tietokone valitsi: k
  Tietokone voitti!
  Tilanne: Pelaaja 2 - 2 Tietokone

  Valitse [k]ivi, [p]aperi tai [s]akset: <font color="red">k</font>
  Tietokone valitsi: k
  Tasapeli.
  Tilanne: Pelaaja 2 - 2 Tietokone

  Valitse [k]ivi, [p]aperi tai [s]akset: 
  Peli päättyi.
  Lopputilanne: Pelaaja 2 - 2 Tietokone
<% end %>

<p>
  Luodaan ohjelmaa varten neljä luokkaa: (1) tekstikäyttöliittymän toteuttamiseen käytettävä luokka <code>Tekstikayttoliittyma</code>, (2) pistetilanteen ylläpitoon käytettävä <code>Pistetilanne</code>, (3) Kivi-paperi-sakset -pelin sääntöjen ylläpitoon käytettävä luokka <code>Saannot</code> ja (4) tietokoneen tarjoaman vastustajan toimintaa kontrolloiva luokka <code>Tekoaly</code>.
</p>



<% partial 'partials/material_sub_heading' do %>
  Tietokoneen "tekoäly"
<% end %>

<p>
  Tekoäly antaa siirron sovellukselle pyydettäessä, jonka lisäksi sille kerrotaan kierroksen lopussa vastustajan siirto. Ensimmäinen tekoäly voi olla hyvin yksinkertainen -- kun tekoäly luodaan erilliseen luokkaan, sitä voidaan jatkossa tarvittaessa parantaa. Luodaan luokasta <code>Tekoaly</code> sellainen, että se palauttaa aina kiven eikä tee tiedolla vastustajan aiemmista siirroista mitään. Ei kovin älykäs siis.
</p>

<p>
  Sovitaan, että ohjelmassa käytetään merkkijonoa "k" kiven kuvaamiseen, "p" paperin kuvaamiseen ja "s" saksien kuvaamiseen.
</p>

<% partial 'partials/code_highlight' do %>
public class Tekoaly {

    public String annaSiirto() {
        return "k";
    }

    public void tallennaVastustajanSiirto(String siirto) {

    }
}
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Pistetilanteen ylläpito
<% end %>

<p>
  Pistetilanteen ylläpito tapahtuu luokan <code>Pistetilanne</code> avulla. Pistetilanne tallentaa sekä pelaajan että tekoälyn pisteet sekä mahdollistaa näiden pisteiden kasvattamisen. Tämän lisäksi pistetilanteen voi tulostaa <code>toString</code>-metodilla. Pistetilanne näyttää seuraavalta.
</p>

<% partial 'partials/code_highlight' do %>
  public class Pistetilanne {

      private int pelaajaPisteet;
      private int tietokonePisteet;

      public Pistetilanne() {
          this.pelaajaPisteet = 0;
          this.tietokonePisteet = 0;
      }

      public void pelaajaVoitti() {
          this.pelaajaPisteet++;
      }

      public void tietokoneVoitti() {
          this.tietokonePisteet++;
      }

      @Override
      public String toString() {
          return "Pelaaja " + this.pelaajaPisteet + " - " + this.tietokonePisteet + " Tietokone";
      }
  }
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Pelin säännöt
<% end %>

<p>
  Hyödynnetään Wikipediaa <a href="https://fi.wikipedia.org/wiki/Kivi,_paperi_ja_sakset"  target="_blank">Kivi, paperi ja sakset</a>-pelin sääntöjen tarkastamiseen. Voitto tai tappio määritellään seuraavalla tavalla.
</p>

<table class="table">
  <tr>
    <th>
      Pelaaja 1
    </th>
    <th>
      Pelaaja 2
    </th>
    <th>
      Voittaja
    </th>
  </tr>
  <tr>
    <td>
      Kivi
    </td>
    <td>
      Sakset
    </td>
    <td>
      Pelaaja 1
    </td>
  </tr>
  <tr>
    <td>
      Kivi
    </td>
    <td>
      Paperi
    </td>
    <td>
      Pelaaja 2
    </td>
  </tr>
  <tr>
    <td>
      Kivi
    </td>
    <td>
      Kivi
    </td>
    <td>
      Tasapeli
    </td>
  </tr>
  <tr>
    <td>
      Sakset
    </td>
    <td>
      Paperi
    </td>
    <td>
      Pelaaja 1
    </td>
  </tr>
  <tr>
    <td colspan="3">
      ...
    </td>
  </tr>
</table>

<p>
  Luodaan sääntöjä varten luokka <code>Saannot</code>, joka palauttaa pelaajan voittaessa merkkijonon "pelaaja", tietokoneen voittaessa merkkijonon "tietokone", ja tasapelin yhteydessä merkkijonon "tasapeli".
</p>

<% partial 'partials/code_highlight' do %>
  public class Saannot {

      public String voittaja(String pelaajanValinta, String tietokoneenValinta) {
          if (pelaajanValinta.equals("k")) {
              if (tietokoneenValinta.equals("p")) {
                  return "tietokone";
              }

              if (tietokoneenValinta.equals("s")) {
                  return "pelaaja";
              }
          }

          if (pelaajanValinta.equals("p")) {
              if (tietokoneenValinta.equals("s")) {
                  return "tietokone";
              }

              if (tietokoneenValinta.equals("k")) {
                  return "pelaaja";
              }
          }

          if (pelaajanValinta.equals("s")) {
              if (tietokoneenValinta.equals("k")) {
                  return "tietokone";
              }

              if (tietokoneenValinta.equals("p")) {
                  return "pelaaja";
              }
          }

          return "tasapeli";
      }
  }
<% end %>

<p>
  Ylläolevan esimerkin voisi toteuttaa myös ohjelmoinnin jatkokurssilla tutuksi tulevien enum-tyyppisten muuttujien avulla (eli järjestettävien ja ennalta määriteltyjen käsitteiden perusteella). Näitä käytettäessä käyttäisimme erillistä käsitettä <code>Siirto</code>, joka tietäisi miten se vertautuu toisiin siirtoihin. Vastaavasti käytössä olisi myös käsite <code>Tulos</code>, joka voisi olla esimerkiksi voitto, tappio tai tasapeli.
</p>


<% partial 'partials/material_sub_heading' do %>
  Tekstikäyttöliittymä
<% end %>

<p>
  Nivotaan edelliset osat yhteen. Tekstikäyttöliittymä on luokka, joka sisältää sovelluslogiikkaan liittyvät oliot oliomuuttujina. Käytössämme olevilla sovelluslogiikan palasilla tekstikäyttöliittymän rakenne on seuraava:
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      // oliomuuttujat
      private Scanner lukija;
      private Tekoaly tekoaly;
      private Saannot saannot;
      private Pistetilanne pistetilanne;

    
      // konstruktori
  
      public void kaynnista() {
          // tervehdysviesti

          // ohjelman toistuva logiikka
          while (true) {

              // syötteen lukeminen

              // lopetusehdon tarkastelu

              // logiikka
          }


          // lopetusviesti
      }
  }  
<% end %>

<p>
  Hahmotellaan metodiin <code>kaynnista</code> käyttöliittymän tekstit.
</p>


<% partial 'partials/code_highlight' do %>
  public void kaynnista() {
      System.out.println("KPS!");
      System.out.println("");

      while (true) {
          System.out.print("Valitse [k]ivi, [p]aperi tai [s]akset: ");
          String pelaajanValinta = lukija.nextLine();

          if (/* lopetusehto */) {
              break;
          }

          String tietokoneenValinta = tekoaly.annaSiirto();
          System.out.println("Tietokone valitsi: " + tietokoneenValinta);

          tekoaly.tallennaVastustajanSiirto(pelaajanValinta);

          String voittaja = saannot.voittaja(pelaajanValinta, tietokoneenValinta);


          // kerro voittaja ja päivitä pisteet

          System.out.println("Tilanne: " + pistetilanne);
          System.out.println("");

      }

      System.out.println("Peli päättyi.");
      System.out.println("Lopputilanne: " + pistetilanne);
  }
<% end %>

<p>
  Lopetusehto on selkeä. Jos käyttäjä ei syötä merkkijonoa k, p tai s, toistosta poistutaan.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean pelaajaHaluaaLopettaa(String pelaajanValinta) {
      return !pelaajanValinta.equals("k")
              && !pelaajanValinta.equals("p")
              && !pelaajanValinta.equals("s");
  }
<% end %>

<p>
  Voittajan kertomiseen ja pisteiden päivittämiseen käytetään sääntöjä ja pistetilannetta.
</p>

<% partial 'partials/code_highlight' do %>
  public void kerroVoittajaJaPaivitaPisteet(String voittaja) {
      if (voittaja.equals("tietokone")) {
          System.out.println("Tietokone voitti!");
          pistetilanne.tietokoneVoitti();
      } else if (voittaja.equals("pelaaja")) {
          System.out.println("Pelaaja voitti!");
          pistetilanne.pelaajaVoitti();
      } else {
          System.out.println("Tasapeli.");
      }
  }
<% end %>

<p>
  Kayttoliittyma on kokonaisuudessaan seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
import java.util.Scanner;

public class Kayttoliittyma {

    private Scanner lukija;
    private Tekoaly tekoaly;
    private Saannot saannot;
    private Pistetilanne pistetilanne;

    public Kayttoliittyma(Scanner lukija, Tekoaly tekoaly, Saannot saannot, Pistetilanne pistetilanne) {
        this.lukija = lukija;
        this.tekoaly = tekoaly;
        this.saannot = saannot;
        this.pistetilanne = pistetilanne;
    }

    public void kaynnista() {
        System.out.println("KPS!");
        System.out.println("");

        while (true) {
            System.out.print("Valitse [k]ivi, [p]aperi tai [s]akset: ");
            String pelaajanValinta = lukija.nextLine();

            if (pelaajaHaluaaLopettaa(pelaajanValinta)) {
                break;
            }

            String tietokoneenValinta = tekoaly.annaSiirto();
            System.out.println("Tietokone valitsi: " + tietokoneenValinta);

            tekoaly.tallennaVastustajanSiirto(pelaajanValinta);

            String voittaja = saannot.voittaja(pelaajanValinta, tietokoneenValinta);

            kerroVoittajaJaPaivitaPisteet(voittaja);

            System.out.println("Tilanne: " + pistetilanne);
            System.out.println("");

        }

        System.out.println("Peli päättyi.");
        System.out.println("Lopputilanne: " + pistetilanne);
    }

    public void kerroVoittajaJaPaivitaPisteet(String voittaja) {
        if (voittaja.equals("tietokone")) {
            System.out.println("Tietokone voitti!");
            pistetilanne.tietokoneVoitti();
        } else if (voittaja.equals("pelaaja")) {
            System.out.println("Pelaaja voitti!");
            pistetilanne.pelaajaVoitti();
        } else {
            System.out.println("Tasapeli.");
        }
    }

    public boolean pelaajaHaluaaLopettaa(String pelaajanValinta) {
        return !pelaajanValinta.equals("k")
                && !pelaajanValinta.equals("p")
                && !pelaajanValinta.equals("s");
    }
}
<% end %>

<p>
  Sovelluksen käynnistäminen onnistuu erillisestä Main-luokasta suoraviivaisesti.
</p>

<% partial 'partials/code_highlight' do %>
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        // Testaa ohjelmasi toimintaa täällä!
        Scanner lukija = new Scanner(System.in);
        Pistetilanne pisteet = new Pistetilanne();
        Tekoaly tekoaly = new Tekoaly();
        Saannot saannot = new Saannot();

        Kayttoliittyma kayttis = new Kayttoliittyma(lukija, tekoaly, saannot, pisteet);
        kayttis.kaynnista();
    }
}
<% end %>

<% partial 'partials/material_sub_heading' do %>
  Pelin jatkokehitys
<% end %>

<p>
  Sovellus toimii nyt halutulla tavalla. Jos ohjelmoija haluaisi muuttaa pelin sääntöjä -- esimerkiksi lisäämällä uusia siirtotyyppejä pelin <a href="http://bigbangtheory.wikia.com/wiki/Rock_Paper_Scissors_Lizard_Spock" target="_blank" norel>Rock, Paper, Scissors, Lizard & Spock</a>-hengessä, muutettavia kohtia on melko paljon, sillä siirtoa ei ole abstrahoitu omaksi käsitteekseen vaan se esitetään merkkijonona.
</p>

<p>
  Toisaalta, tekoäly on kapseloitu sovelluksessa hyvin, jolloin sen jatkokehitys on suoraviivaista. Selkeä parannus edelliseen tekoälyyn olisi pelata aina sellainen siirto, joka voittaa pelaajan edellisen siirron. Tämä onnistuisi seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  public class Tekoaly {
      private String vastustajanSiirto;

      public Tekoaly() {
          this.vastustajanSiirto = "k";
      }

      public String annaSiirto() {
          if (this.vastustajanSiirto.equals("k")) {
              return "p";
          } else if (this.vastustajanSiirto.equals("p")) {
              return "s";
          } else {
              return "k";
          }
      }
   
      public void tallennaVastustajanSiirto(String siirto) {
          this.vastustajanSiirto = siirto;
      }
  }
<% end %>


<% partial 'partials/exercise', locals: { name: 'Kivi, paperi ja sakset tekoäly (2 osaa)' } do %>

  <p>
    Tehtäväpohjassa on edellisessä esimerkissä kuvattu kivi, paperi, sakset -peli. Pelin tekoäly on kuitenkin harmittavan heikko. Tässä tehtävässä kehität pelin tekoälyä.
  </p>

  <p>
    Eräs hyvä tekoälystrategia perustuu tietoon siitä, että ihmisten toiminta on helposti ennakoitavissa.
  </p>

  <p>
    Laajenna Tekoaly-luokkaa siten, että se pitää kirjaa vastustajan tekemistä siirroista listassa. Metodi tallennaVastustajanSiirto lisää vastustajan siirron tekoälyn muistiin.
  </p>

  <p>
    Muuta Tekoaly-luokan annaSiirto-metodia siten, että se käyttää muistissa olevaa listaa seuraavan siirron tekemiseen. Tässä erittäin hyvä strategia on katsoa vastustajan viimeisintä kahta siirtoa ja etsiä vastustajan pelihistoriasta niitä seuraava todennäköisin siirto.
  </p>

  <p>
    Tarkastellaan esimerkiksi tilannetta, missä tekoälyn muistissa on siirrot [p, p, k, k, s, p, k, k, s, p, k, k]. Vastustajan kaksi viimeisintä siirtoa ovat kivi ja kivi. Muistin perusteella voidaan laskea "todennäköisyydet" sille, että seuraava siirto on kivi, paperi tai sakset. 
  </p>

  <ul>
    <li>kivi, kivi, kivi: esiintyy muistissa 0 kertaa.</li>
    <li>kivi, kivi, paperi: esiintyy muisissa 0 kertaa.</li>
    <li>kivi, kivi, sakset: esiintyy muistissa 2 kertaa.</li>
  </ul>

  <p>
    Muistin perusteella arvaamme, että pelaajan seuraava siirto on "sakset". Tekoälyn kannattaa siis pelata kivi.
  </p>

  <p>
    Tämä tehtävä vastaa kahta yksiosaista tehtävää. Tehtävään ei ole testejä -- testaa tekoälyn toimintaa pelaamalla sitä vastaan itse.
  </p>
    
<% end %>


<% partial 'partials/exercise', locals: { name: 'Lintubongarin tietokanta (3 osaa)' } do %>

  <p><b>Tehtävä vastaa kolmea yksiosaista tehtävää. </b></p>

  <p>
    Tässä tehtävässä suunnittelet ja toteutat tietokannan lintubongareille. Tietokanta sisältää lintuja, joista jokaisella on nimi (merkkijono) ja latinankielinen nimi (merkkijono). Tämän lisäksi tietokanta laskee kunkin linnun havaintokertoja.
  </p>

  <p>
    Ohjelmasi täytyy toteuttaa seuraavat komennot:
  </p>

  <ul>
    <li><code>Lisaa</code> - lisää linnun (<b>huom:</b> komennon nimessä ei ä-kirjainta!)</li>
    <li><code>Havainto</code> - lisää havainnon</li>
    <li><code>Tilasto</code> - tulostaa kaikki linnut</li>
    <li><code>Nayta</code> - tulostaa yhden linnun (<b>huom:</b> komennon nimessä ei ä-kirjainta!)</li>
    <li><code>Lopeta</code> - lopettaa ohjelman</li>
  </ul>

  <p>
    Lisäksi virheelliset syötteet pitää käsitellä. (Ks. <code>Simo</code> alla). Tässä vielä esimerkki ohjelman toiminnasta:
  </p>

  <% partial 'partials/sample_output' do %>
    ? <font color="red">Lisaa</font>
    Nimi: <font color="red">Korppi</font>
    Latinankielinen nimi: <font color="red">Corvus Corvus</font>
    ? <font color="red">Lisaa</font>
    Nimi: <font color="red">Haukka</font>
    Latinankielinen nimi: <font color="red">Dorkus Dorkus</font>
    ? <font color="red">Havainto</font>
    Mikä havaittu? <font color="red">Haukka</font>
    ? <font color="red">Havainto</font>
    Mikä havaittu? <font color="red">Simo</font>
    Ei ole lintu!
    ? <font color="red">Havainto</font>
    Mikä havaittu? <font color="red">Haukka</font>
    ? <font color="red">Tilasto</font>
    Haukka (Dorkus Dorkus): 2 havaintoa
    Korppi (Corvus Corvus): 0 havaintoa
    ? <font color="red">Nayta</font>
    Mikä? <font color="red">Haukka</font>
    Haukka (Dorkus Dorkus): 2 havaintoa
    ? <font color="red">Lopeta</font>
  <% end %>

  <p>
    <strong>Huom!</strong> Ohjelmasi rakenne on täysin vapaa. Testaamme vain että <code>Paaohjelma</code> luokan <code>main</code>-metodi toimii kuten tässä on kuvailtu. Hyödyt tehtävässä todennäköisesti ongelma-aluetta sopivasti kuvaavista luokista.
  </p>
  
<% end %>


<% partial 'partials/material_heading' do %>
  Tiedon ryhmittely hajautustaulun avulla
<% end %>


<p>
  Hajautustaulu sisältää korkeintaan yhden arvon yhtä avainta kohti. Seuraavassa esimerkissä tallennamme henkilöiden puhelinnumeroita hajautustauluun.
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, String&gt; puhelinnumerot = new HashMap&lt;&gt;();
  puhelinnumerot.put("Pekka", "040-12348765");

  System.out.println("Pekan numero: " + puhelinnumerot.get("Pekka"));

  puhelinnumerot.put("Pekka", "09-111333");

  System.out.println("Pekan numero: " + puhelinnumerot.get("Pekka"));
<% end %>

<% partial 'partials/sample_output' do %>
  Pekan numero: 040-12348765
  Pekan numero: 09-111333
<% end %>


<p>
  Entä jos haluaisimme liittää yhteen avaimeen useita arvoja, eli esimerkiksi useampia puhelinnumeroita yhdelle henkilölle?
</p>

<p>
  Koska hajautustaulun avaimet ja arvot voivat olla mitä tahansa muuttujia, listojen käyttäminen hajautustaulun arvona onnistuu. Useamman arvon lisääminen yhdelle arvolle onnistuu liittämällä avaimeen lista. Muutetaan puhelinnumeroiden talletustapaa seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, ArrayList&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;&gt;();
<% end %>

<p>
  Nyt hajautustaulussa on jokaiseen avaimeen liitettynä lista. Vaikka new-komento luo hajautustaulun, ei hajautustaulu sisällä alussa yhtäkään listaa. Ne on luotava tarvittaessa erikseen.
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, ArrayList&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;&gt;();

  // liitetään Pekka-nimeen ensin tyhjä ArrayList
  puhelinnumerot.put("Pekka", new ArrayList&lt;&gt;());

  // ja lisätään Pekkaa vastaavalle listalle puhelinnumero
  puhelinnumerot.get("Pekka").add("040-12348765");
  // ja lisätään toinenkin puhelinnumero
  puhelinnumerot.get("Pekka").add("09-111333");

  System.out.println("Pekan numerot: " + puhelinnumerot.get("Pekka"));
<% end %>

<% partial 'partials/sample_output' do %>
  Pekan numero: [040-12348765, 09-111333]
<% end %>

<p>
  Määrittelimme muuttujan puhelinnumero tyypiksi <code>HashMap&lt;String, ArrayList&lt;String&gt;&gt;</code>. Tämä tarkoittaa hajautustaulua, joka käyttää avaimena merkkijonoa ja arvona merkkijonoja sisältävää listaa. Hajautustauluun lisättävät arvot ovat siis konkreettisia listoja.
</p>

<% partial 'partials/code_highlight' do %>
  // liitetään Pekka-nimeen ensin tyhjä ArrayList
  puhelinnumerot.put("Pekka", new  ArrayList&lt;&gt;());

  // ...
<% end %>

<p>
  Vastaavalla tyylillä voi toteuttaa esimerkiksi tehtävien pistekirjanpidon. Alla olevassa esimerkissä on hahmoteltu luokkaa <code>Tehtavakirjanpito</code>, mikä sisältää käyttäjäkohtaisen pistekirjanpidon. Käyttäjä esitetään merkkijonona ja pisteet kokonaislukuina. 

<% partial 'partials/code_highlight' do %>
  public class Tehtavakirjanpito {
      private HashMap&lt;String, ArrayList&lt;Integer&gt;&gt; tehdytTehtavat;

      public Tehtavakirjanpito() {
          this.tehdytTehtavat = new HashMap&lt;&gt;();
      }

      public void lisaa(String kayttaja, int tehtava) {
          // uudelle käyttäjälle on lisättävä HashMapiin tyhjä lista jos sitä
          // ei ole jo lisätty
          this.tehdytTehtavat.putIfAbsent(kayttaja, new ArrayList&lt;&gt;());

          // haetaan ensin käyttäjän tehtävät sisältävä lista ja tehdään siihen lisäys
          ArrayList&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
          tehdyt.add(tehtava);

          // edellinen olisi onnitunut myös ilman apumuuttujaa seuraavasti
          // this.tehdytTehtavat.get(kayttaja).add(tehtava);
      }

      public void tulosta() {
          this.tehdytTehtavat.entrySet().stream().forEach(entry -&gt; {
              System.out.println(entry.getKey() + ": " + entry.getValue());
          });
      }
  }
<% end %>

<% partial 'partials/code_highlight' do %>
  Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
  kirjanpito.lisaa("Ada", 3);
  kirjanpito.lisaa("Ada", 4);
  kirjanpito.lisaa("Ada", 3);
  kirjanpito.lisaa("Ada", 3);

  kirjanpito.lisaa("Pekka", 4);
  kirjanpito.lisaa("Pekka", 4);

  kirjanpito.lisaa("Matti", 1);
  kirjanpito.lisaa("Matti", 2);

  kirjanpito.tulosta();
<% end %>

<% partial 'partials/sample_output' do %>
  Matti: [1, 2]
  Pekka: [4, 4]
  Ada: [3, 4, 3, 3]
<% end %>


<% partial 'partials/exercise', locals: { name: 'Usean käännöksen sanakirja' } do %>

  <p>
    Tehtävänäsi on toteuttaa luokka <code>UseanKaannoksenSanakirja</code>, johon voidaan lisätä yksi tai useampi käännös jokaiselle sanalle. Luokan tulee toteuttaa seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaa(String sana, String kaannos)</code> lisää käännöksen sanalle säilyttäen vanhat käännökset</li>
    <li><code>public ArrayList&lt;String&gt; kaanna(String sana)</code> palauttaa listan, joka sisältää sanojen käännökset. Jos sanalle ei ole yhtäkään käännöstä, metodin tulee palauttaa tyhjä lista.</li>
    <li><code>public void poista(String sana)</code> poistaa sanan ja sen kaikki käännökset sanakirjasta.</li>
  </ul>

  <p>
    Käännökset kannattanee lisätä <code>HashMap&lt;String, ArrayList&lt;String&gt;&gt;</code>-tyyppiseen oliomuuttujaan.
  </p>

  <p>
    Esimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    UseanKaannoksenSanakirja sanakirja = new UseanKaannoksenSanakirja();
    sanakirja.lisaa("kuusi", "six");
    sanakirja.lisaa("kuusi", "spruce");

    sanakirja.lisaa("pii", "silicon");
    sanakirja.lisaa("pii", "pi");

    System.out.println(sanakirja.kaanna("kuusi"));
    sanakirja.poista("pii");
    System.out.println(sanakirja.kaanna("pii"));
  <% end %>

  <% partial 'partials/sample_output' do %>
    [six, spruce]
    []
  <% end %>

<% end %>



<% partial 'partials/material_heading' do %>
  Satunnaisuus ohjelmissa
<% end %>


<p>
  Satunnaisuutta tarvitaan esimerkiksi salausalgoritmeissa, koneoppimisessa sekä tietokonepelien ennustettavuuden vähentämisessä. Satunnaisuutta mallinnetaan käytännössä <em>satunnaislukujen</em> avulla, joiden luomiseen Java valmiin <code>Random</code>-luokan. Random-luokasta voi tehdä olion jota voi käyttää seuraavalla tavalla.
</p>

<% partial 'partials/code_highlight' do %>
import java.util.Random;

public class Arvontaa {
    public static void main(String[] args) {
        Random arpoja = new Random(); // luodaan arpoja apuväline
        int i = 0;

        while (i &lt; 10) {
            // Arvotaan ja tulostetaan jokaisella kierroksella satunnainen luku
            System.out.println(arpoja.nextInt(10));
            i++;
        }
    }
}
<% end %>

<p>
  Yllä olevassa koodissa luodaan ensin <code>Random</code>-luokasta olio käyttäen avainsanaa <code>new</code> -- samoin kuin muitakin olioita luodessa. Random-olio tarjoaa metodin <code>nextInt</code>, jolle annetaan parametrina kokonaisluku. Metodi palauttaa satunnaisen kokonaisluvun väliltä <em>0..(annettu kokonaisluku - 1)</em>.
</p>

<p>
  Ohjelman tulostus voisi olla vaikka seuraavanlainen:
</p>

<% partial 'partials/sample_output' do %>
2
2
4
3
4
5
6
0
7
8
<% end %>

<p>
  Satunnaisia kokonaislukuja voidaan käyttää esimerkiksi nopanheittojen mallintamiseen.
</p>

<% partial 'partials/exercise', locals: { name: 'Noppa' } do %>

  <p>
    Tehtäväpohjassa on luokka <code>Noppa</code>, jonka runko on seuraava:
  </p>
  
  <% partial 'partials/code_highlight' do %>
import java.util.Random;

public class Noppa {
    private Random random;
    private int tahkojenMaara;

    public Noppa(int tahkojenMaara) {
        this.random = new Random();
        // Alusta oliomuuttuja tahkojenMaara tässä 
    }

    public int heita() {
        // arvo täällä luku jonka tulee olla yhdestä tahkojen määrään
        // ([1-tahkojenMaara]) ja palauta se
    }
}
  <% end %>

  <p>
    Muokkaa luokkaa siten, että sen konstruktori<code>Noppa(int tahkojenMaara)</code> luo uuden noppa-olion annetulla nopan tahkojen (eri oman numeronsa sisältämien "puolien") määrällä. Muokkaa myös metodia <code>heita</code> siten, että se antaa satunnaisen nopanheiton tuloksen, jonka arvon tulee olla väliltä <code>1...tahkojen määrä</code> (vinkki: plus!).
  </p>

  <p>
    Seuraavassa noppaa testaava pääohjelma:
  </p>

  <% partial 'partials/code_highlight' do %>
public class Ohjelma {
    public static void main(String[] args) {
        Noppa noppa = new Noppa(6);

        int i = 0;
        while (i &lt; 10) {
            System.out.println(noppa.heita());
            i++;
        }
    }
}
  <% end %>

  <p>
    Tulostus voisi olla esimerkiksi seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
1
6
3
5
3
3
2
2
6
1
  <% end %>

<% end %>

<p>
  Random-luokasta tehdyn olion kautta päästään käsiksi myös satunnaisiin liukulukuihin, joita käytetään muunmuassa todennäköisyyslaskennan yhteydessä; tietokoneilla todennäköisyyksiä simuloidaan yleensä väliltä [0..1] olevilla luvuilla.
</p>

<p>
  Random-oliolta satunnaisia liukulukuja saa metodilla <code>nextDouble</code>. Tarkastellaan seuraavia säämahdollisuuksia:
</p>

<ul>
  <li>Sataa räntää todennäköisyydellä 0.1 (10%)</li>
  <li>Sataa lunta todennäköisyydellä 0.3 (30%)</li>
  <li>Aurinko paistaa todennäköisyydellä 0.6 (60%)</li>
</ul>

<p>
  Luodaan edellä olevista arvioista sääennustaja.
</p>

<% partial 'partials/code_highlight' do %>
import java.util.ArrayList;
import java.util.Random;

public class SaaEnnustaja {
    private Random random;

    public SaaEnnustaja() {
        this.random = new Random();
    }

    public String ennustaSaa() {
        double todennakoisyys = this.random.nextDouble();

        if (todennakoisyys &lt;= 0.1) {
            return "Sataa räntää";
        } else if (todennakoisyys &lt;= 0.4) { // 0.1 + 0.3
            return "Sataa lunta";
        } else { // loput, 1.0 - 0.4 = 0.6
            return "Aurinko paistaa";
        }
    }

    public int ennustaLampotila() {
        return (int) (4 * this.random.nextGaussian() - 3);
    }
}
<% end %>

<p>
  Metodi <code>ennustaLampotila</code> on monella tapaa mielenkiintoinen. Metodin sisällä tehtävä kutsu <code>this.random.nextGaussian()</code> on tavallinen metodikutsu, jonka kaltaisia olemme nähneet aikaisemminkin. Kiinnostavaa tässä <code>Random</code>-luokan ilmentymän tarjoamassa metodissa on se, että metodin palauttama luku on <em>normaalijakautunut</em> (jos et koe mielenkiintoa satunnaisuuden eri lajeihin se ei haittaa!).
</p>

<% partial 'partials/code_highlight' do %>
public int ennustaLampotila() {
    return (int) (4 * this.random.nextGaussian() - 3);
}
<% end %>

<p>
  Edellisessä esimerkissä käytetään eksplisiittistä tyyppimuunnosta liukulukujen muuntamiseen kokonaisluvuiksi <code>(int)</code>. Vastaavalla menetelmällä voidaan muuttaa myös kokonaislukuja liukuluvuiksi kirjoittamalla <code>(double) kokonaisluku</code>
</p>

<p>
  Luodaan vielä pääohjelma josta luokkaa <code>SaaEnnustaja</code> käytetään.
</p>

<% partial 'partials/code_highlight' do %>
public class Ohjelma {

    public static void main(String[] args) {
        SaaEnnustaja ennustaja = new SaaEnnustaja();

        // tallennetaan päivät listalle
        ArrayList&lt;String&gt; paivat = new ArrayList&lt;&gt;();
        paivat.add("Ma");
        paivat.add("Ti");
        paivat.add("Ke");
        paivat.add("To");
        paivat.add("Pe");
        paivat.add("La");
        paivat.add("Su");

        System.out.println("Seuraavan viikon sääennuste:");
        paivat.stream().forEach(paiva -&gt; {
            String saaEnnuste = ennustaja.ennustaSaa();
            int lampotilaEnnuste = ennustaja.ennustaLampotila();

            System.out.println(paiva + ": " + saaEnnuste + " " + lampotilaEnnuste + " astetta.");
        });
    }
}
<% end %>

<p>
  Ohjelman tulostus voisi olla esimerkiksi seuraavanlainen:
</p>


<% partial 'partials/sample_output' do %>
Seuraavan viikon sääennuste:
Ma: Sataa lunta 1 astetta.
Ti: Sataa lunta 1 astetta.
Ke: Aurinko paistaa -2 astetta.
To: Aurinko paistaa 0 astetta.
Pe: Sataa lunta -3 astetta.
La: Sataa lunta -3 astetta.
Su: Aurinko paistaa -5 astetta
<% end %>

<% partial 'partials/exercise', locals: { name: 'Lottoarvonta' } do %>

  
  <p>
    Tehtävänäsi on täydentää luokkaa <code>Lottorivi</code>, joka arpoo viikon lottonumerot. Lottonumerot ovat väliltä 1&ndash;40 ja niitä arvotaan 7. Lottorivi koostuu siis seitsemästä eri numerosta väliltä 1&ndash;40. Luokassa on seuraavat toiminnot:
  </p>
  
  <ul>
    <li> konstruktori <code>Lottorivi</code> luo uuden Lottorivi-olion joka sisältää uudet, arvotut numerot</li>
    <li> metodi <code>numerot</code> palauttaa tämän lottorivin lottonumerot</li>
    <li> metodi <code>sisaltaaNumeron</code> kertoo onko arvotuissa numeroissa annettu numero</li>
    <li> metodi <code>arvoNumerot</code> arpoo riville uudet numerot</li>
  </ul>
  
  <p>
    Luokan runko on seuraava:
  </p>
    
  <% partial 'partials/code_highlight' do %>
import java.util.ArrayList;
import java.util.Random;

public class LottoRivi {
    private ArrayList&lt;Integer&gt; numerot;

    public LottoRivi() {
        // Arvo numerot heti LottoRivin luomisen yhteydessä
        this.arvoNumerot();
    }

    public ArrayList&lt;Integer&gt; numerot() {
        return this.numerot;
    }

    public boolean sisaltaaNumeron(int numero) {
        // Testaa tässä onko numero jo arvottujen numeroiden joukossa
    }

    public void arvoNumerot() {
        // Alustetaan lista numeroille
        this.numerot = new ArrayList&lt;&gt;();
        // Kirjoita numeroiden arvonta tänne käyttämällä metodia sisaltaaNumeron()
    }
}
  <% end %>
  
  <p>
    Tehtäväpohjan mukana tulee seuraava pääohjelma:
  </p>

  <% partial 'partials/code_highlight' do %>
import java.util.ArrayList;

public class Ohjelma {
    public static void main(String[] args) {
        Lottorivi rivi = new Lottorivi();
        ArrayList&lt;Integer&gt; lottonumerot = rivi.numerot();

        System.out.println("Lottonumerot:");
        lottonumerot.stream().forEach(numero -&gt; {
            System.out.print(numero + " ");
        });

        System.out.println("");
    }
}
  <% end %>
  
  <p>
    Ohjelman mahdollisia tulostuksia ovat seuraavat:
  </p>

  <% partial 'partials/sample_output' do %>
Lottonumerot:
3 5 10 14 15 27 37
  <% end %>

  <% partial 'partials/sample_output' do %>
Lottonumerot:
2 9 11 18 23 32 34
  <% end %>
  
  <p>
    <strong>Huom!</strong> Sama numero saa esiintyä lottorivissä vain kerran. Lottorivin numeroiden ei tarvitse olla järjestyksessä.
  </p>

<% end %>

<% partial 'partials/hint', locals: { name: 'Lukujen satunnaisuudesta' } do %>

  <p>
    Tietokoneiden toiminta on ennustettavissa sillä ne suorittavat niille annettuja komentoja orjallisesti. Ovatko siis tietokoneen luomat luvut todellisuudessa satunnaisia?
  </p>

  <p>
    Tietokoneohjelmissa käytetyt satunnaisluvut ovat tyypillisesti pseudosatunnaislukuja, eli ne vaikuttavat satunnaisluvuilta, mutta seuraavat todellisuudessa jonkinlaista algoritmisesti luotua toistuvaa lukusarjaa. Suurimmalle osalle tietokoneohjelmista pseudosatunnaisluvut ovat riittävän hyviä -- esimerkiksi youtube-videoiden satunnaisessa toistossa normaali käyttäjä tuskin huomaa eroa. Toisaalta, jos satunnaislukuja käytetään tieteelliseen laskentaan, heikosti toimivat pseudosatunnaislukuja luovat algoritmit saattavat jopa johtaa tulosten kyseenalaistamiseen. Eräs esimerkki tällaisesta on hetken 1960-luvulla käytössä ollut IBM:n <a href="https://en.wikipedia.org/wiki/RANDU" target="_blank" norel>RANDU</a>.
  </p>
  
  <p>
    Kaikki tietokoneohjelmien satunnaisuus ei kuitenkaan ole pseudosatunnaisuutta. Vahvempaan satunnaisuuteen pyrkivät ohjelmat hyödyntävät muunmuassa jonkinlaisia tosielämän satunnaiseksi ajateltuja ilmiöitä satunnaislukujen luomiseen. Tällaisia ilmiöitä ovat esimerkiksi avaruussäteily tai vaikkapa <a href="https://www.wired.com/2003/08/random/" target="_blank" norel>laavalamppujen toiminta</a>.
  </p>

  <p>
    Lisää aiheesta osoitteessa <a href="https://www.random.org/randomness/" target="_blank" norel>https://www.random.org/randomness/</a>.
  </p>
  
<% end %>



<% partial 'partials/material_heading' do %>
  Simulaatiot
<% end %>

<p>
  Simulaatiot ovat ohjelmia, joilla pyritään kuvaamaan tai ennustamaan jonkinlaista todellista ilmiötä. Tutustutaan simulaatioihin kolmen tehtävän kautta. Kaikissa tehtävissä on käytössä kaksiulotteinen maailma, jota mallinnetaan hajautustaulun avulla. Alla on kuvattu kaksiulotteisen hajautustaulu toimintaa:
</p>

<% partial 'partials/code_highlight' do %>

  // luodaan hajautustaulu
  HashMap&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; taulukko = new HashMap<>();

  // yllä olevassa hajautustaulussa jokainen x-koordinaatti viittaa uuteen hajautustauluun:
  // näitä ei ole kuitenkaan vielä tehty, joten alustetaan kaikki arvot nolliksi

  // luodaan 10 x 10 kokoinen maailma, missä kaikki arvot ovat nollia

  int leveys = 10;
  int korkeus = 10;
  
  int x = 0;
  while (x &lt; leveys) {
      taulukko.putIfAbsent(x, new HashMap<>());

      int y = 0;
      while (y &lt; korkeus) {
          taulukko.get(x).put(y, 0);
          y++;
      }

      x++;
  }

  // asetetaan kohtaan (3, 2) arvo 5
  taulukko.get(x).put(y, 5);

  // haetaan arvo kohdasta (0, 1) ja tulostetaan se
  System.out.println(taulukko.get(x).get(y));
<% end %>

<% partial 'partials/exercise', locals: { name: 'Satunnaiskävely' } do %>

  <p>
    Oletetaan, että henkilö aloittaa kävelynsä pisteestä (0, 0). Tietämättä maailmasta enempää, onko mahdollista, että henkilö voi kulkea pisteeseen (20, 20)?
  </p>

  <p>
    Kursseilla tietorakenteet ja algoritmit sekä johdatus tekoälyyn tarkastellaan muunmuassa reitinhakualgoritmeja, joiden avulla voidaan selvittää nopeimpia reittejä annettujen pisteiden välillä. Tässä tarkastelemme ongelmaa hieman erilaisen menetelmän avulla ja tutustumme satunnaiskävelyyn (satunnaiskulku, random walk).
  </p>

  <p>
    Satunnaiskävelyssä todennäköisyydet liikkeelle ovat näennäisesti satunnaisia. Toteutettavassa tapauksessamme henkilö liikkuu seuraavasti: 20% todennäköisyydellä hän pysyy paikallaan, 20% todennäköisyydellä hän liikkuu oikealle, 20% todennäköisyydellä hän liikkuu vasemmalle, 20% todennäköisyydellä hän liikkuu ylös, ja 20% todennäköisyydellä hän liikkuu alas.
  </p>

  <p>
    Jos algoritmi ei ole saavuttanut pistettä (20, 20) hyvin ison askelmäärän jälkeen, voimme ehdottaa, että pisteeseen (20, 20) ei ole pääsyä. 
  </p>

  <p>
    Tehtäväpohjassa on annettu satunnaiskävelyn piirtämistä varten luotu ohjelma, missä kaksiulotteista maailmaa maillinnetaan kahden sisäkkäisen HashMap-tietorakenteen avulla seuraavasti<code>HashMap&lt;Integer, HashMap&lt;Integer, Double&gt;&gt; taulukko</code>. Koordinaatissa 0, 0 olevaan arvoon pääsee käsiksi kutsumalla <code>taulukko.get(20).get(20)</code>.
  </p>

  <p>
    Tehtäväpohjassa on lisäksi mallinnettu tilannetta, missä jokainen askel jättää hiljalleen haihtuvan jäljen.
  </p>

  <p>
    Tehtävänäsi on tutustua ohjelmaan ja lisätä siihen toiminnallisuus, missä jokainen askel on satunnainen. Henkilön askelten tulee tapahtua seuraavasti: 20% todennäköisyydellä henkilö pysyy paikallaan, 20% todennäköisyydellä henkilö liikkuu oikealle, 20% todennäköisyydellä henkilö liikkuu vasemmalle, 20% todennäköisyydellä henkilö liikkuu ylös, ja 20% todennäköisyydellä henkilö liikkuu alas.
  </p>

  <p>
    Alla on kuvakaappaus eräästä satunnaiskävelystä.
  </p>

  <img src="/img/satunnaiskavely.gif" alt="Esimerkki (lyhyestä) satunnaiskävelystä)"/>
  
  <p>
    Vaikka <a href="https://en.wikipedia.org/wiki/Random_walk" target="_blank" norel>Random walk</a> -menetelmä tuntuu hyvin yksinkertaiselta, sillä on monia sovelluksia. Sitä käytetään muunmuassa molekyylien satunnaisen liikkeen mallintamisessa, osakkeiden hintojen muutosten mallintamisessa, ja geenien satunnaisissa muutoksissa.
  </p>

  <p>
    Tehtävään ei ole testejä -- palauta se kun se toimii halutusti.
  </p>
  
<% end %>


<% partial 'partials/exercise', locals: { name: 'Game of Life (2 osaa)' } do %>

  <p>
    <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life" target="_blank" rel="noopener">Game of Life</a> on neljää yksinkertaista sääntöä seuraava soluautomaatti:
  </p>

  <ol>
    <li>Jos elävän solun naapureina on alle kaksi elävää solua, se kuolee alikansoituksen takia.</li>
    <li>Jos elävän solun naapureina on kaksi tai kolme elävää solua, se jää henkiin.</li>
    <li>Jos elävän solun naapureina on yli kolme elävää solua, se kuolee ylikansoituksen takia.</li>
    <li>Jos kuolleen solun naapureina on tasan kolme elävää solua, se syntyy eli muuttuu eläväksi.</li>
  </ol>

  <p>
    Peli ei sisällä minkäänlaisia liikkumissääntöjä, mutta se silti luo tilanteita, missä erilaiset hahmot liikkuvat ruudulla. Katso pelin keksineen <a href="https://youtu.be/E8kUJL04ELA" target="_blank" rel="noopener">John Conwayn mietteitä pelistä sekä sääntöjen selitys</a>.
  </p>

  <p>
    Tässä tehtävässä toteutetaan oleellisilta osin Game of Life-pelin säännöt. Toteutusta varten tehtäväpohjassa on luokka GameOfLife, joka sisältää hajautustaulun avulla toteutetun kaksiulotteisen taulukon, sekä luokka GameOfLifeSovellus, jota voidaan käyttää pelin visualisointiin.
  </p>
  

  <h2>Elossa olevien naapurien lukumäärä</h2>

  <p>
    Täydennä luokassa GameOfLife olevaa metodia <code>public int elossaOleviaNaapureita(HashMap&lt;Integer, HashMap&lt;Integer, Boolean>> taulukko, int x, int y)</code> siten, että se laskee annetun x, y -koordinaatin elossa olevien naapureiden lukumäärän. Naapuri on elossa jos sen arvo on 1.
  </p>

  <p>
    Esimerkiksi kohdassa (0, 0) oleva alkio on elossa jos kutsu <code>taulukko.get(x).get(y)</code> palauttaa arvon <code>true</code>.
  </p>

  <p>
    Naapureita ovat kaikki ne alkiot, jotka ovat kulman tai sivun kautta yhteydessä alkioon.
  </p>

  <p>
    Huomaa, että metodin tulee varoa taulukon ulkopuolelle menemistä. Indeksissä -1 ei esimerkiksi voi olla ketään. Vastaavasti leveyden tai korkeuden yli ei voi mennä (esim. <code>taulukko.get(taulukko.size()).get(0)</code> tai <code>taulukko.get(0).get(taulukko.size())</code>).
  </p>

  <p>
    Esimerkiksi, jos taulukko on seuraavanlainen:
  </p>

  <table border="1">

    
    <tr>
      <td>
	x=0,y=0: true
      </td>
      <td>
	x=1,y=0: false
      </td>
      <td>
	x=2,y=0: false
      </td>
    </tr>
    
    <tr>
      <td>
	x=0,y=1: true
      </td>
      <td>
	x=1,y=1: true
      </td>
      <td>
	x=2,y=1: false
      </td>
    </tr>

    <tr>
      <td>
	x=0,y=2: false
      </td>
      <td>
	x=1,y=2: false
      </td>
      <td>
	x=2,y=2: true
      </td>
    </tr>

  </table>

  <p>
    Palauttavat seuraavat kutsut seuraavat arvot:
  </p>
  
  <% partial 'partials/code_highlight' do %>
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 0, 0));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 0));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 1));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 2, 2));
  <% end %>

  <% partial 'partials/sample_output' do %>
    2
    3
    3
    1
  <% end %>

  
  <h2>Kehittyminen</h2>

  <p>
    Täydennä seuraavaksi GameOfLife-luokan metodia <code>public void kehity()</code> siten, että se käy yhden Game of Life -pelin askeleen.
  </p>

  <p>
    Toteuta toiminnallisuus niin, että luot toisen taulukon, jonka koko on sama kuin alkuperäisen taulukon. Käy tämän jälkeen alkuperäistä taulukkoa läpi alkio alkiolta siten, että seuraat seuraavia sääntöjä:
  </p>

  <ol>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on alle kaksi elävää naapuria, kopioon asetetaan alkion arvoksi 0.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on kaksi tai kolme elävää naapuria, kopioon asetetaan alkion arvoksi 1.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on yli kolme elävää naapuria, kopioon asetetaan alkion arvoksi 0.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 0 ja sillä on tasan kolme elävää naapuria, kopioon asetetaan alkion arvoksi 1.</li>
  </ol>

  <p>
    Käytä naapureiden lukumäärän selvittämisessä edellisessä osassa tehtyä metodia. Kun olet käynyt koko taulukon läpi, vaihda kopio taulukon paikalle.
  </p>


  <p>
    Kokeile tämän jälkeen sovelluksen toimintaa graafisen käyttöliittymän kautta. Sovelluksen pitäisi käynnistyä -- yksi mahdollinen hetkellinen tila on seuraavanlainen.
  </p>

  <img src="/img/exercises/06-15-gameoflife.png" width="600"/>


<% end %>


<% partial 'partials/exercise', locals: { name: 'Schelling (2 osaa)' } do %>

  <p>
    <a href="https://en.wikipedia.org/wiki/Thomas_Schelling" target="_blank" rel="noopener">Thomas Schelling</a> on yhdysvaltalainen taloustieteilijä, joka esitti ihmisten eriytymistä selittävän mallin. Malli perustuu ajatukselle, että vaikka ihmiset asetettasiin satunnaisesti asumaan, he muuttavat pois jos he eivät ole tyytyväisiä naapureihinsa.
  </p>

  <p>
    Tässä tehtävässä pohditaan Schellingin mallia sekä kehitetään siihen liittyvää simulaatio-ohjelmaa.
  </p>

  <p>
    Simulaation suoritus alkaa tilanteesta, missä ihmiset ovat asetettu satunnaisesti asumaan.
  </p>

  <img src="/img/exercises/schelling-alku.png" alt="Tilanne, missä ihmiset asuvat satunnaisesti."/>

  <p>
    &nbsp;
  </p>

  <p>
    Kun simulaatio etenee, päädytään ennen pitkää tilanteeseen, missä samankaltaiset ihmiset ovat muuttaneet samankaltaisten ihmisten luo.
  </p>

  <img src="/img/exercises/schelling-loppu.png" alt="Ihmiset ovat muuttaneet sopivampiin paikkoihin."/>

  <p>
    &nbsp;
  </p>

  <p>
    Simulaatio-ohjelmasta puuttuu muutamia oleellisia toiminnallisuuksia: (1) kartan tyhjennys, (2) tyhjien paikkojen etsiminen, sekä (3) tyytymättömien henkilöiden tunnistaminen. Kannattaa ennen aloitusta tutustua nykyiseen tehtävän koodiin -- ohjelmassa on mukana myös visualisointiin käytettävä komponentti.
  </p>


  <h2>Kartan tyhjentäminen ja tyhjien paikkojen etsiminen</h2>

  <p>
    Simulaatiomallissa käytetään sisäkkäistä hajautustaulua kaksiulotteisen taulukon kuvaamiseen. Kohdassa (x, y) oleva arvo 0 kuvaa tyhjää paikkaa ja luvut 1-5 kuvaavat eri ryhmiä.
  </p>

  <p>
    Toteuta ensin luokan <code>Eriytymismalli</code> metodiin <code>public void asetaKaikkiTyhjiksi()</code> toiminnallisuus, joka asettaa jokaisen solun arvoksi 0.
  </p>

  <p>
    Lisää tämän jälkeen metodiin <code>public ArrayList&lt;Piste&gt; tyhjatPaikat()</code> toiminnallisuus, joka tunnistaa tyhjät paikat (solut, joissa on arvo 0), luo jokaisesta Piste-olion, ja palauttaa ne listana. Huomaa, että käytössä olevassa hajautustaulussa ensimmäinen ulottuvuus kuvaa x-koordinaattia, ja toinen y-koordinaattia (taulukko.get(x).get(y)).
  </p>


  <h2>Tyytymättömien hakeminen</h2>

  <p>
    Mallille voidaan asettaa parametri <code>tyytyvaisyysraja</code>. Tyytyväisyysrajalla kuvataan samaan ryhmään kuuluvien naapureiden minimimäärää, millä henkilö on tyytyväinen sijaintiinsa. Jos ruudussa (x, y) olevan henkilön naapureista on samankaltaisia yhtä paljon tai yli <code>tyytyvaisyysraja</code>n, on henkilö tyytyväinen. Muissa tapauksissa henkilö on tyytymätön.
  </p>

  <p>
    Naapureista tulee tarkastella kaikkia ruudun vieressä olevia ruutuja. Alueen ulkopuolella olevat ruudut (esim. -1, 0) tulee käsitellä tyhjänä ruutuna (ei samankaltainen).
  </p>

  <p>
    Toteuta metodi <code>public ArrayList&lt;Piste&gt; haeTyytymattomat()</code>, joka palauttaa tyytymättömät listana.
  </p>

  <p>
    Kun metodi on toteutettu, ihaile ohjelman toimintaa :)
  </p>


  <p>
    <em>
      Vaikka karttamme on suorakulmio, voisi sen yhtä hyvin piirtää vaikkapa Helsingin muotoiseksi.
    </em>
  </p>

<% end %>




<% partial 'partials/material_heading' do %>
  Kurssin lopuksi
<% end %>

<p>
  Kurssin lopuksi vielä pieni pähkinätehtävä, jonka parhaiten pärjääviä toteutuksia tarkastellaan ohjelmoinnin jatkokurssin ensimmäisellä luennolla.
</p>

<% partial 'partials/exercise', locals: { name: 'Uno (2 osaa)' } do %>

  <p>
    <a href="https://fi.wikipedia.org/wiki/Uno_(korttipeli)" target="_blank" rel="noopener">Uno</a> on korttipeli, missä jokaisella pelaajalla on kädessään kortteja. Kortteja pelataan vuorotellen siten, että jokainen pelaaja pelaa aina yhden kortin kerrallaan. Pelin voittaja on se, jonka kädestä loppuu kortit ensimmäisenä kesken.
  </p>

  <p>
    Suurimmalla osalla korteista on väri -- Punainen, Vihreä, Sininen tai Keltainen -- ja kortin saa pelata edellisen pelaajan pelaaman kortin jälkeen jos kortilla on sama väri tai numero kuin edellisellä kortilla. Pelissä on lisäksi joukko erikoiskortteja. Osalla niistä on väri ja ne saa pelata vain jos edellisessä kortissa on sama väri. Osalla erikoiskorteista ei ole väriä. Värittömät kortit saa pelata minkä tahansa kortin jälkeen (pelaaminen tapahtuu kuitenkin aina omalla vuorolla).
  </p>

  <ul>
    <li>
      Värilliset erikoiskortit ovat "Ohitus", "Suunnanvaihto" ja "Nosta 2". Kun pelaaja pelaa kortin "Ohitus", seuraavalta pelaajalta jää vuoro välistä. Kortti "Suunnanvaihto" kääntää pelin suuntaa (esim. myötäpäivästä vastapäivään), ja "Nosta 2" lisää seuraavalle pelaajalle kaksi korttia sekä jättää häneltä vuoron välistä.
    </li>
    <li>
      Värittömät erikoiskortit ovat "Villi kortti" ja "Villi kortti + Nosta 4". Molemmat kortit antavat kortin pelaavalle pelaajalle mahdollisuuden valita seuraavaksi pelattava väri. Tämän lisäksi kortti "Villi kortti + Nosta 4" lisää seuraavalle pelaajalle 4 korttia sekä jättää häneltä vuoron välistä.
    </li>
  </ul>

  <p>
    Pelin tavoitteena on saada kortit loppumaan. Kun tämä tapahtuu, ensimmäisenä korttinsa loppuun pelannut pelaaja saa pisteitä muiden pelaajien käteen jääneistä korteista. Pisteet lasketaan seuraavasti: numerokortit ovat kortissa olevan numeron arvoisia, värilliset erikoiskortit ovat 20 pisteen arvoisia, ja värittömät erikoiskortit ovat 50 pisteen arvoisia. Uusia pelejä pelataan kunnes joku pelaajista saavuttaa 500 pistettä.
  </p>

  <p>
    Tässä tehtävässä rakennetaan Uno-peliä varten tekoäly. Ennen aloittamista, kokeile tehtäväpohjassa olevan pelin käynnistämistä ja pelaamista. Peli käynnistetään tehtäväpohjan Main-luokasta.
  </p>

  <hr/>

  <p>
    Tekoäly tulee toteuttaa luokkaan <code>Tekoalypelaaja</code>. Luokalle on valmiiksi määriteltynä <em>rajapinta</em> (palaamme tähän myöhemmissä osissa) ja kolme metodia.
  </p>

  <ul>
    <li>
      <p>
	Metodi <code>public int pelaa(ArrayList&lt;Kortti&gt, omatKortit, Kortti paallimmaisin, String vari, Pelitilanne tilanne)</code> on tekoälyn ydin ja sen tehtävänä on päättää mikä kortti pelataan seuraavaksi. Metodi saa parametrina pelaajan kädessä olevat kortit (omatKortit), viimeksi pelatun kortin minkä päälle pelataan (paallimmaisin), edellisen pelaajan valitseman värin jos viimeksi pelattu kortti oli villi kortti (vari), sekä yleisen pelitilanteen (tilanne). Pelitilanne-luokasta kerrotaan enemmän tehtävänannon lopussa.
	<br/>
	Tehtävänäsi on toteuttaa ohjelma, joka palauttaa pelattavan kortin indeksin. Jos käytettävissä ei ole yhtäkään sopivaa korttia, metodin tulee palauttaa arvo -1, jolloin nostetaan kortti. Huomaa, että pelissä tulee pelata kortti jos se vain on mahdollista.
      </p>
    </li>

    <li>
      <p>
	Metodia <code>public String valitseVari(ArrayList&lt;Kortti&gt; omatKortit)</code> kutsutaan kun tekoäly pelaa villin kortin eli vaihtaa pelattavaa väriä. Metodin tulee palauttaa joku seuraavista merkkijonoista: "Punainen", "Vihreä", "Sininen", "Keltainen".
      </p>
    </li>

    <li>
      <p>
	Metodi <code>public String nimi()</code> kertoo tekoälysi nimen, jonka saat luonnollisesti keksiä itse. Tekoälyn nimi saattaa ilmestyä jonkinlaisiin turnauslistoihin, eli pidä nimi ns. kilttinä.
      </p>
    </li>
  </ul>

  <p>
    Tehtävänäsi on tutustua ohjelmaan sekä toteuttaa luokkaan Tekoalypelaaja tekoäly, joka toimii oikein, eli se pelaa aina sallitun kortin. Oikein toimiva tekoäly on kahden tehtäväpisteen arvoinen.
  </p>

  <p>
    Kun olet saanut toteutettua oikein toimivan tekoälyn, viilaa sitä paremmaksi.
  </p>

  <p>
    Kun tehtävän määräaika on ohi, jokaisen palauttamaa (toimivaa) tekoälyä peluutetaan kaikkia muita tekoälyjä vastaan useampaan otteeseen. Parhaille tekoälyille on tiedossa myös palkintoja.
  </p>


  <hr/>

  <p>
    Vinkkejä viilaamiseen:
  </p>

  <ul>
    <li>
      Koska häviötilanteessa käden pisteet menevät voittajalla, saattaa olla hyvä idea pyrkiä pelaamaan ensin kortit, joiden pistearvo on suuri.
    </li>
    <li>
      Toisaalta, esimerkiksi villit kortit saattavat olla erittäin hyödyllisiä myöhemmässä vaiheessa peliä, eli niistä kannattanee pitää kiinni.
    </li>
    <li>
      Tai no, ehkä villeistä korteista ei kannata pitää ikuisesti kiinni, koska ne kuitenkin ovat 50 pisteen arvoisia.
    </li>
    <li>
      Kun pelaat villin kortin ja valitset värin, voi olla ihan fiksua valita väri, jota sinulla on paljon kädessä.
    </li>
    <li>
      Toiisaalta sitten, jos kädessäsi on punaiset 0, 1 ja 6 ja vihreä 9 sekä vihdeä nosta 2, voi olla kuitenkin ihan fiksua yrittää ensin hankkiutua eroon vihreistä korteista, sillä niiden pistearvo on hyvin suuri.
    </li>
    <li>
      Pohdi tilannetta, missä pöydällä on punainen 5 ja kädessäsi on punainen 3 sekä sininen 5. Kannattaako sinun pelata punainen vai vihreä kortti? Tässä on pohdittavana sekä mahdollinen pistesaldo että syy punaisen kortin pöydällä olemiseen. Entäpä jos vastustaja on pelannut punaisen kortin koska hänellä on punaisia kortteja jäljellä?
    </li>
    <li>
      Jokaista nollakorttia löytyy pelistä vain yksi, mutta jokaista numerokorttia on kaksi. Nollan pelaaminen ei vaikuta käden pisteisiin, mutta sen pelaaminen saattaa johtaa tilanteeseen, missä on epätodennäköisempää että jollain muulla on sama numero. Tällöin todennäköisyys värin vaihdolle saattaa olla pienempi..
    </li>
    <li>
      Kaikkiin näihin vinkkeihin varmaankin vaikuttaa myös kädessä olevien korttien määrä. Pienellä määrällä kortteja voi olla ehkäpä hyvä ottaa riskejä ja yrittää voittaa peli. Toisaalta sitten, jos kädessä on paljon kortteja, kannattaa ehkä unohtaa kyseisen kierroksen voitto ja pyrkiä minimoimaan vastustajalle menevien pisteiden määrä.
    </li>
    <li>
      Ainiin, muutkin osallistujat lukevat näitä vinkkejä.. Löytyisiköhän joillekin edeltäville vinkeille jonkinlainen käänteisstrategia?
    </li>
  </ul>

  <hr/>

  <p>
    Pelitilanne-luokka sisältää havaintoja tähän asti kuluneesta pelistä sekä lisätietoa kehittyneemmille tekoälyille. Se tarjoaa seuraavat metodit:
  </p>

  <ul>
    <li>
      Metodi <code>public String getSuunta()</code> palauttaa pelin tämänhetkisen suunnan. Suunta on joko "Myötäpäivään" eli eteenpäin tai "Vastapäivään" eli taaksepäin.
    </li>
    <li>
      Metodi <code>public int getOmaIndeksi()</code> palauttaa oman tekoälyn indeksin. Indeksiä käytetään seuraavissa metodeissa.
    </li>
    <li>
      Metodi <code>public HashMap&lt;Integer, Integer&gt; getPelaajienPisteet()</code> kertoo tämänhetkisen pistetilanteen kaikille pelaajille.
    </li>
    <li>
      Metodi <code>public HashMap&lt;Integer, Integer&gt; getPelaajienKorttienLukumaarat()</code> kertoo pelaajien tämänhetkisen korttien lukumäärän.
    </li>
    <li>
      Metodi <code>public HashMap&lt;Integer, String&gt; getPelaajienViimeksiPelaamatVarit()</code> kertoo pelaajien viimeksi pelaamat värit. Alkiossa on arvo null jos pelaaja ei ole vielä pelannut korttia.
    </li>
  </ul>

  <p>
    <em>
      Tehtävän alkuperäinen idea: Stephen Davies, UMW
    </em>
  </p>


<% end %>



<%= partial 'partials/quiz', locals: { id: '59e382a8c6dd020004fdd9b2' } %>

