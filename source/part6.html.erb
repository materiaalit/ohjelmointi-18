---
  title: Osa 6
  exercise_page: true
  quiz_page: true
  published: true
---


<% partial 'partials/hint', locals: { name: 'Kuudennen osan tavoitteet' } do %>

  <p>
    Osaa käsitellä listassa olevaa tietoa virtana (stream-metodi) sekä tuntee muutamia virran perusoperaatioita (filter, map, collect). Tuntee käsitteen tiedosto. Osaa lukea tietoa erilaisista tietolähteistä (mm. tiedosto, verkko). Ymmärtää hajautustaulun periatteen. Osaa kirjoittaa hajautustaulua käyttäviä ohjelmia. Tutustuu sovelluksen pilkkomisen useampaan vastuualueeseen (tekstikäyttöliittymä, sovelluslogiikka).
  </p>

<% end %>



<% partial 'partials/material_heading' do %>
  Lista arvojen virtana
<% end %>

<p>
  Tutustutaan listan läpikäyntiin arvojen virtana (stream). Virta on menetelmä tietoa sisältävän kokoelman läpikäyntiin siten, että ohjelmoija määrittelee kullekin listan arvolle suoritettavan toiminnallisuuden. Indeksistä tai kullakin hetkellä käsiteltävästä muuttujasta ei pidetä kirjaa.
</p>

<p>
  Virran avulla ohjelmoija määrittelee funktioketjun, joita kutsutaan tietokokoelman arvoille. Virran avulla voi muuntaa tietoa muodosta toiseen, mutta virta ei muuta alkuperäisen tietokokoelman arvoja.
</p>

<p>
  Tutustutaan virran käyttöön konkreettisen esimerkin kautta. Tarkastellaan seuraavaa ongelmaa:
</p>

<p>
  <em>
    Kirjoita ohjelma, joka lukee käyttäjältä syötteitä ja tulostaa niihin liittyen tilastoja. Kun käyttäjä syöttää merkkijonon "loppu", lukeminen lopetetaan. Muut syötteet ovat lukuja. Kun syötteiden lukeminen lopetetaan, ohjelma tulostaa kolmella jaollisten positiivisten lukujen lukumäärän sekä kaikkien lukujen keskiarvon.
  </em>
</p>

<% partial 'partials/code_highlight' do %>
  // alustetaan lukija ja lista, johon syotteet luetaan
  Scanner lukija = new Scanner(System.in);
  ArrayList&lt;String&gt; syotteet = new ArrayList&lt;&gt;();

  // luetaan syotteet
  while (true) {
      String rivi = lukija.nextLine();
      if (rivi.equals("loppu")) {
          break;
      }
  
      syotteet.add(rivi);
  }

  // selvitetään kolmella jaollisten lukumaara
  long kolmellaJaollistenLukumaara = syotteet.stream()
                                             .mapToInt(s -&gt; Integer.parseInt(s))
                                             .filter(luku -&gt; luku % 3 == 0)
                                             .count();

  // selvitetään keskiarvo
  double keskiarvo = syotteet.stream()
                             .mapToInt(s -&gt; Integer.parseInt(s))
                             .average()
                             .getAsDouble();

  // tulostetaan tilastot
  System.out.println("Kolmella jaollisia: " + kolmellaJaollistenLukumaara);
  System.out.println("Lukujen keskiarvo: " + keskiarvo);
<% end %>

<p>
  Tarkastellaan tarkemmin yllä kuvatun ohjelman osaa, missä luettuja syötteitä käsitellään virtana. 
</p>

<% partial 'partials/code_highlight' do %>
  // selvitetään kolmella jaollisten lukumaara
  long kolmellaJaollistenLukumaara = syotteet.stream()
                                             .mapToInt(s -&gt; Integer.parseInt(s))
                                             .filter(luku -&gt; luku % 3 == 0)
                                             .count();
<% end %>

<p>
  Virta luodaan ArrayList-oliosta metodilla <code>stream()</code>. Tämän jälkeen merkkijonomuotoiset arvot muunnetaan kokonaislukumuotoon virran metodilla <code>mapToInt(arvo -&gt; muunnos)</code> -- muunto toteutetaan Integer-luokan tarjoamalla parseInt-metodilla, jota olemme käyttäneet aiemminkin. Seuraavaksi rajaamme metodilla <code>filter(arvo -&gt; rajausehto)</code> käsiteltäväksi vain ne luvut, jotka ovat kolmella jaollisia. Lopulta kutsumme virran metodia <code>count()</code>, joka laskee virran alkioiden lukumäärän ja palauttaa sen <code>long</code>-tyyppisenä muuttujana.
</p>

<p>
  Tarkastellaan tämän jälkeen listan alkioiden keskiarvon laskemiseen tarkoitettua ohjelmaa.
</p>

<% partial 'partials/code_highlight' do %>
  // selvitetään keskiarvo
  double keskiarvo = syotteet.stream()
                             .mapToInt(s -&gt; Integer.parseInt(s))
                             .average()
                             .getAsDouble();
<% end %>

<p>
  Keskiarvon laskeminen onnistuu virrasta, jolle on kutsuttu <code>mapToInt</code>-metodia. Kokonaislukuja sisältävällä virralla on metodi <code>average()</code>, joka palauttaa <a href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalDouble.html" target="_blank" norel>OptionalDouble</a>-tyyppisen olion. Oliolla on metodi <code>getAsDouble()</code>, joka palauttaa listan arvojen keskiarvon <code>double</code>-tyyppisenä muuttujana.
</p>

<p>
  Lyhyt yhteenveto tähän mennessä tutuiksi tulleista virtaan liittyvistä metodeista.
</p>

<table class="table">
  <tr>
    <th>
      Tarkoitus ja metodi
    </th>
    <th>
      Oletukset
    </th>
  </tr>

  <tr>
    <td>
      Virran luominen: <code>stream()</code>
    </td>
    <td>
      Metodia kutsutaan kokoelmalle kuten ArrayList-oliolle. Luotavalle virralle tehdään jotain.
    </td>
  </tr>

  <tr>
    <td>
      Virran muuntaminen kokonaislukuvirraksi: <code>mapToInt(arvo -&gt; toinen)</code>
    </td>
    <td>
      Virta muuntuu kokonaislukuja sisältäväksi virraksi. Merkkijonoja sisältävä muunnos voidaan tehdä esimerkiksi Integer-luokan parseInt-metodin avulla. Kokonaislukuja sisältävälle virralle tehdään jotain.
    </td>
  </tr>

  <tr>
    <td>
      Arvojen rajaaminen: <code>filter(arvo -&gt; hyvaksymisehto)</code>
    </td>
    <td>
      Virrasta rajataan pois ne arvot, jotka eivät täytä hyväksymisehtoa. "Nuolen" oikealla puolella on lauseke, joka palauttaa totuusarvon. Jos totuusarvo on <code>true</code>, arvo hyväksytään virtaan. Jos totuusarvo on <code>false</code>, arvoa ei hyväksytä virtaan. Rajatuille arvoille tehdään jotain.
    </td>
  </tr>
  
  <tr>
    <td>
      Keskiarvon laskeminen: <code>average()</code>
    </td>
    <td>
      Palauttaa OptionalDouble-tyyppisen olion, jolla on <code>double</code> tyyppisen arvon palauttava metodi <code>getAsDouble()</code>. Metodin <code>average()</code> kutsuminen onnistuu kokonaislukuja sisältävälle virralle (luominen onnistuu <code>mapToInt</code>-metodilla.
    </td>
  </tr>

  <tr>
    <td>
      Virrassa olevien alkioiden lukumaara: <code>count()</code>
    </td>
    <td>
      Palauttaa virrassa olevien alkioiden lukumäärän <code>long</code>-tyyppisenä arvona.
    </td>
  </tr>
  
</table>

<% partial 'partials/exercise', locals: { name: 'Lukujen keskiarvo' } do %>

  <p>
    Harjoitellaan lukujen lukemista listalle sekä listan arvojen keskiarvon laskemista virran avulla.
  </p>

  <p>
    Toteuta ohjelma, joka lukee käyttäjältä syötteitä. Jos käyttäjä syöttää merkkijonon "loppu", lukeminen lopetetaan. Muut syötteet ovat lukuja. Kun käyttäjä syöttää merkkijonon "loppu", ohjelman tulee tulostaa syötettyjen lukujen keskiarvo.
  </p>


  <% partial 'partials/sample_output' do %>
    Kirjoita syötteitä, "loppu" lopettaa.
    <font color="red">2</font>
    <font color="red">4</font>
    <font color="red">6</font>
    <font color="red">loppu</font>
    Lukujen keskiarvo: 4.0
  <% end %>
  

  <% partial 'partials/sample_output' do %>
    Kirjoita syötteitä, "loppu" lopettaa.
    <font color="red">-1</font>
    <font color="red">1</font>
    <font color="red">2</font>
    <font color="red">loppu</font>
    Lukujen keskiarvo: 0.6666666666666666
  <% end %>
    
<% end %>

<% partial 'partials/exercise', locals: { name: 'Tiettyjen lukujen keskiarvo' } do %>

  <p>
    Harjoitellaan lukujen lukemista listalle sekä listan arvojen rajaamista virran avulla.
  </p>

  <p>
    Toteuta ohjelma, joka lukee käyttäjältä syötteitä. Jos käyttäjä syöttää merkkijonon "loppu", lukeminen lopetetaan. Muut syötteet ovat lukuja. Kun käyttäjä syöttää merkkijonon "loppu", syötteiden lukeminen lopetetaan.
  </p>

  <p>
    Tämän jälkeen käyttäjältä kysytään tulostetaanko negatiivisten vai positiivisten lukujen keskiarvo (n vai p). Jos käyttäjä syöttää merkkijonon "n", tulostetaan negatiivisten lukujen keskiarvo, muulloin tulostetaan positiivisten lukujen keskiarvo.
  </p>


  <% partial 'partials/sample_output' do %>
    Kirjoita syötteitä, "loppu" lopettaa.
    <font color="red">-1</font>
    <font color="red">1</font>
    <font color="red">2</font>
    <font color="red">loppu</font>
    
    Tulostetaanko negatiivisten vai positiivisten lukujen keskiarvo? (n/p)
    <font color="red">n</font>
    Negatiivisten lukujen keskiarvo: -1.0
  <% end %>

  <% partial 'partials/sample_output' do %>
    Kirjoita syötteitä, "loppu" lopettaa.
    <font color="red">-1</font>
    <font color="red">1</font>
    <font color="red">2</font>
    <font color="red">loppu</font>
    
    Tulostetaanko negatiivisten vai positiivisten lukujen keskiarvo? (n/p)
    <font color="red">p</font>
    Positiivisten lukujen keskiarvo: 1.5
  <% end %>
  
<% end %>


<% partial 'partials/hint', locals: { name: 'Mikä ihmeen <code>x -&gt; ???</code>' } do %>

  <p>
    Virran arvoja käsitellään virtaan liittyvillä metodeilla. Arvoja käsittelevät metodit saavat parametrinaan funktion, joka kertoo mitä kullekin arvolle tulee tehdä. Funktion toiminnallisuus on metodikohtaista: rajaamiseen käytetylle metodille <code>filter</code> annetaan funktio, joka palauttaa totuusarvoisen muuttujan arvon <code>true</code> tai <code>false</code>, riippuen halutaanko arvo säilyttää virrassa; muuntamiseen käytetylle metodille <code>mapToInt</code> annetaan funktio, joka muuntaa arvon kokonaisluvuksi, jne.
  </p>

  <p>
    Miksi funktiot kirjoitetaan muodossa <code>luku -&gt; luku &gt; 5</code>?
  </p>

  <p>
    Kyseinen kirjoitusmuoto on Javan tarjoama lyhenne. Saman funktion voi kirjoittaa useammalla eri tavalla -- funktio sisältää sekä funktion parametrien määrittelyn että funktion rungon. Saman voi kirjoittaa useammassa muodossa, kts. alla.
  </p>

  <% partial 'partials/code_highlight' do %>
    // alkuperäinen
    .filter(luku -&gt; luku &gt; 5)

    // on sama kuin
    .filter((Integer luku) -&gt; 
        if (luku &gt; 5) {
            return true;
        }
    
        return false;
    })
  <% end %>

  <p>
    Käytännössä kyseessä on ns. anonyymi funktio. Saman voi kirjoittaa myös eksplisiittisesti niin, että ohjelmaan määrittelee staattisen metodin, jota kutsutaan virran metodista. Tämä tapahtuisi seuraavasti.
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Rajaajat {
        public static boolean vitostaSuurempi(int luku) {
            return luku &gt; 5;
        }
    }

  <% end %>  

  <% partial 'partials/code_highlight' do %>
    // alkuperäinen
    .filter(luku -&gt; luku &gt; 5)

    // on sama kuin
    .filter(luku -&gt; Rajaajat.vitostaSuurempi(luku))
  
    // on sama kuin
    .filter(Rajaajat::vitostaSuurempi);
  <% end %>

  <p>
    Virran arvoja käsittelevät funktiot eivät voi muuttaa funktion ulkopuolisten muuttujien arvoja. Kyse on käytännössä lähes samasta kuin metodeja kutsuessa -- metodia kutsuttaessa metodin ulkopuolisiin muuttujiin ei pääse käsiksi. Funktioiden tilanteessa funktion ulkopuolisten muuttujien arvoja voi lukea olettaen, että luettavien muuttujien arvot eivät muutu lainkaan ohjelmassa.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Virran metodit
<% end %>

<p>
  Virran metodit voi jakaa karkeasti kahteen eri ryhmään: virran (1) arvojen käsittelyyn tarkoitettuihin välioperaatioihin sekä (2) käsittelyn lopettaviin pääteoperaatiohin. Edellisessä esimerkissä nähdyt metodit <code>filter</code> ja <code>mapToInt</code> ovat välioperaatioita. Välioperaatiot palauttavat arvonaan virran, jonka käsittelyä voi jatkaa -- käytännössä välioperaatioita voi olla käytännössä ääretön määrä ketjutettuna peräkkäin (pisteellä eroteltuna). Toisaalta edellisessä esimerkissä nähty metodi <code>average</code> on pääteoperaatio. Pääteoperaatio palauttaa käsiteltävän arvon, joka luodaan esimerkiksi virran arvoista.
</p>

<p>
  Alla olevassa kuvassa on kuvattu virran toimintaa. Lähtötilanteena (1) on lista, jossa on arvoja. Kun listalle kutsutaan <code>stream()</code>-metodia, (2) luodaan virta listan arvoista. Arvoja käsitellään tämän jälkeen yksitellen. Virran arvoja voidaan (3) rajata metodilla <code>filter</code>. Tämä poistaa virrasta ne arvot, jotka ovat rajauksen ulkopuolella. Virran metodilla <code>map</code> voidaan (4) muuntaa virrassa olevia arvoja muodosta toiseen. Metodi <code>collect</code> (5) kerää virrassa olevat arvot arvot sille annettuun kokoelmaan, esim. listalle.
</p>

<img src="/img/drawings/stream.png" alt="Yllä tekstuaalisesti kuvattu virran toiminta kuvana." />

<p>&nbsp;</p>

<p>
  Alla vielä yllä olevan kuvan kuvaama esimerkki ohjelmakoodina.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Integer&gt; lista = new ArrayList&lt;&gt;();
  lista.add(3);
  lista.add(7);
  lista.add(4);
  lista.add(2);
  lista.add(6);

  ArrayList&lt;Integer&gt; luvut = lista.stream()
                                  .filter(luku -&gt; luku &gt; 5)
                                  .map(luku -&gt; luku * 2)
                                  .collect(Collectors.toCollection(ArrayList::new));
<% end %>

  
<% partial 'partials/material_sub_sub_heading' do %>
  Pääteoperaatiot
<% end %>

<p>
  Tarkastellaan tässä kolmea pääteoperaatiota: listan arvojen lukumäärän selvittämistä <code>count</code>-metodin avulla, listan arvojen läpikäyntiä <code>forEach</code>-metodin avulla sekä listan arvojen keräämistä tietorakenteeseen <code>collect</code>-metodin avulla.
</p>

<p>
  Metodi <code>count</code> kertoo virran alkioiden lukumäärän <code>long</code>-tyyppisenä muuttujana.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
  luvut.add(3);
  luvut.add(2);
  luvut.add(17);
  luvut.add(6);
  luvut.add(8);

  System.out.println("Lukuja: " + luvut.stream().count());
<% end %>

<% partial 'partials/sample_output' do %>
  Lukuja: 5
<% end %>


<p>
  Metodi <code>forEach</code> kertoo mitä kullekin listan arvolle tulee tehdä ja samalla päättää virran käsittelyn. Alla olevassa esimerkissä luodaan ensin numeroita sisältävä lista, jonka jälkeen tulostetaan vain kahdella jaolliset luvut.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
  luvut.add(3);
  luvut.add(2);
  luvut.add(17);
  luvut.add(6);
  luvut.add(8);

  luvut.stream()
       .filter(luku -&gt; luku % 2 == 0)
       .forEach(luku -&gt; System.out.println(luku));
<% end %>

<% partial 'partials/sample_output' do %>
  2
  6
  8
<% end %>


<p>
  Virran arvojen kerääminen toiseen kokoelmaan onnistuu metodin <code>collect</code> avulla. Alla olevassa esimerkissä luodaan uusi lista annetun positiivisista arvoista.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
  luvut.add(3);
  luvut.add(2);
  luvut.add(-17);
  luvut.add(-6);
  luvut.add(8);

  ArrayList&lt;Integer&gt; positiiviset = luvut.stream()
                                         .filter(luku -&gt; luku > 0)
                                         .collect(Collectors.toCollection(ArrayList::new));

  positiiviset.stream()
              .forEach(luku -&gt; System.out.println(luku));
<% end %>

<% partial 'partials/sample_output' do %>
  3
  2
  8
<% end %>



<% partial 'partials/exercise', locals: { name: 'Jaolliset' } do %>

  <p>
    Tehtävässä harjoitellaan virran <code>filter</code> ja <code>collect</code>-metodien käyttöä.
  </p>

  <p>
    Tehtäväpohjassa on annettuna metodirunko <code>public static ArrayList&lt;Integer&gt jaolliset(ArrayList&lt;Integer&gt; luvut)</code>. Toteuta metodirunkoon toiminnallisuus, kerää parametrina saadulta listalta kahdella, kolmella tai viidellä jaolliset luvut, ja palauttaa ne uudessa listassa. Metodille parametrina annetun listan ei tule muuttua.
  </p>
  
  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
    luvut.add(3);
    luvut.add(2);
    luvut.add(-17);
    luvut.add(-5);
    luvut.add(7);
    
    ArrayList&lt;Integer&gt; jaolliset = jaolliset(luvut);

    jaolliset.stream()
             .forEach(luku -&gt; System.out.println(luku));
  <% end %>

  
  <% partial 'partials/sample_output' do %>
    3
    2
    -17
  <% end %>  

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Välioperaatiot
<% end %>

<p>
  Virran välioperaatiot ovat metodeja, jotka palauttavat arvonaan virran. Koska palautettava arvo on virta, voidaan välioperaatioita kutsua peräkkäin. Tyypillisiä välioperaatioita ovat arvon muuntaminen muodosta toiseen <code>map</code> sekä sen erityistapaus <code>mapToInt</code>, arvojen rajaaminen <code>filter</code>, uniikkien arvojen tunnistaminen <code>distinct</code> sekä arvojen järjestäminen <code>sorted</code> (mikäli mahdollista).
</p>

<p>
  Tarkastellaan näitä metodeja muutaman ongelman avulla. Oletetaan, että käytössämme on seuraava luokka Henkilo.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      private String etunimi;
      private String sukunimi;
      private int syntymavuosi;

      public Henkilo(String etunimi, String sukunimi, int syntymavuosi) {
          this.etunimi = etunimi;
          this.sukunimi = sukunimi;
          this.syntymavuosi = syntymavuosi;
      }

      public String getEtunimi() {
          return this.etunimi;
      }

      public String getSukunimi() {
          return this.sukunimi;
      }

      public int getSyntymavuosi() {
          return this.syntymavuosi;
      }
  }
<% end %>


<p>
  <em>
    Ongelma 1: Saat käyttöösi listan henkilöitä. Tulosta ennen vuotta 1970 syntyneiden henkilöiden lukumäärä.
  </em>
</p>

<p>
  Käytetään <code>filter</code>-metodia henkilöiden rajaamiseen niihin, jotka ovat syntyneet ennen vuotta 1970. Lasketaan tämän jälkeen henkilöiden lukumäärä metodilla <code>count</code>.
</p>

<% partial 'partials/code_highlight' do %>
  // oletetaan, että käytössämme on lista henkiloita
  // ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;&gt;();

  long lkm = henkilot.stream()
                     .filter(henkilo -&gt; henkilo.getSyntymavuosi() &lt; 1970)
                     .count();
  System.out.println("Lukumäärä: " + lkm);
<% end %>


<p>
  <em>
    Ongelma 2: Saat käyttöösi listan henkilöitä. Kuinka monen henkilön etunimi alkaa kirjaimella "A"?
  </em>
</p>

<p>
  Käytetään <code>filter</code>-metodia henkilöiden rajaamiseen niihin, joiden etunimi alkaa kirjaimella "A". Lasketaan tämän jälkeen henkilöiden lukumäärä metodilla <code>count</code>.
</p>

<% partial 'partials/code_highlight' do %>
  // oletetaan, että käytössämme on lista henkiloita
  // ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;&gt;();

  long lkm = henkilot.stream()
                     .filter(henkilo -&gt; henkilo.getEtunimi().startsWith("A"))
                     .count();
  System.out.println("Lukumäärä: " + lkm);
<% end %>

<p>
  <em>
    Ongelma 3: Saat käyttöösi listan henkilöitä. Tulosta henkilöiden uniikit etunimet aakkosjärjestyksessä.
  </em>
</p>

<p>
  Käytetään ensin <code>map</code>-metodia, jonka avulla henkilö-olioita sisältävä virta muunnetaan etunimiä sisältäväksi virraksi. Tämän jälkeen kutsutaan metodia <code>distinct</code>, joka palauttaa virran, jossa on uniikit arvot. Seuraavaksi kutsutaan metodia <code>sorted</code>, joka järjestää merkkijonot. Lopulta kutsutaan metodia <code>forEach</code>, jonka avulla tulostetaan merkkijonot.
</p>

<% partial 'partials/code_highlight' do %>
  // oletetaan, että käytössämme on lista henkiloita
  // ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;&gt;();

  henkilot.stream()
          .map(henkilo -&gt; henkilo.getEtunimi())
          .distinct()
          .sorted()
          .forEach(nimi -&gt; System.out.println(nimi));
<% end %>


<% partial 'partials/exercise', locals: { name: 'Luettujen arvojen tulostaminen' } do %>

  <p>
    Kirjoita ohjelma, joka lukee käyttäjältä merkkijonoja. Lukeminen tulee lopettaa kun käyttäjä syöttää tyhjän merkkijonon. Tulosta tämän jälkeen käyttäjän syöttämät merkkijonot.
  </p>

  <% partial 'partials/sample_output' do %>
    <font color="red">eka</font>
    <font color="red">toka</font>
    <font color="red">kolmas</font>
    eka
    toka
    kolmas
  <% end %>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Rajatut luvut' } do %>

  <p>
    Kirjoita ohjelma, joka lukee käyttäjältä lukuja. Kun käyttäjä syöttää negatiivisen luvun, lukeminen lopetetaan. Tulosta tämän jälkeen ne luvut, jotka ovat välillä 1-5.
  </p>

  <% partial 'partials/sample_output' do %>
    <font color="red">7</font>
    <font color="red">14</font>
    <font color="red">4</font>
    <font color="red">5</font>
    <font color="red">4</font>
    <font color="red">-1</font>
    4
    5
    4
  <% end %>

<% end %>



<% partial 'partials/exercise', locals: { name: 'Uniikit sukunimet' } do %>

  <p>
    Tehtäväpohjaan on hahmoteltu ohjelmaa, joka lukee käyttäjältä syötteenä henkilötietoja. Täydennä ohjelmaa siten, että tietojen lukemisen jälkeen ohjelma tulostaa henkilöiden uniikit sukunimet aakkosjärjestyksessä.
  </p>

  
  <% partial 'partials/sample_output' do %>
    Syötetäänkö henkilöiden tietoja, "loppu" lopettaa: 
    Syötä etunimi: <font color="red">Ada</font>
    Syötä sukunimi: <font color="red">Lovelace</font>
    Syötä syntymävuosi: <font color="red">1815</font>

    Syötetäänkö henkilöiden tietoja, "loppu" lopettaa: 
    Syötä etunimi: <font color="red">Grace</font>
    Syötä sukunimi: <font color="red">Hopper</font>
    Syötä syntymävuosi: <font color="red">1906</font>

    Syötetäänkö henkilöiden tietoja, "loppu" lopettaa: 
    Syötä etunimi: <font color="red">Alan</font>
    Syötä sukunimi: <font color="red">Turing</font>
    Syötä syntymävuosi: <font color="red">1912</font>
    
    Syötetäänkö henkilöiden tietoja, "loppu" lopettaa: loppu
    
    Uniikit sukunimet aakkosjärjestyksessä:
    Hopper
    Lovelace
    Turing
  <% end %>

  <p>
    Ohjelmassa ei ole valmiita automaattisia testejä. Voit kirjoittaa automaattisia testejä testiluokkaan <code>UniikitSukunimetTest</code> -- tässä tapauksessa olisi näppärää tehdä esimerkiksi erillinen listan palauttava metodi uniikkien sukunimien tunnistamiseen sille parametrina annetusta henkilölistasta. 
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Oliot ja virta
<% end %>

<p>
  Olioiden käsittely virran metodien avulla on luontevaa. Kukin virran metodi, missä käsitellään virran arvoja, mahdollistaa myös arvoihin liittyvän metodin kutsumisen. Tarkastellaan vielä esimerkkiä, missä käytössämme on Kirjoja, joilla on kirjailijoita. Oletetaan, että kirjailijat ovat edellä kuvattuja Henkilo-olioita. Oletetaan lisäksi, että käytössämme on alla kuvattu luokka Kirja.
</p>
  

<% partial 'partials/code_highlight' do %>
  public class Kirja {
      private Henkilo kirjailija;
      private String nimi;
      private int sivujenLukumaara;
  
      public Kirja(Henkilo kirjailija, String nimi, int sivuja) {
          this.kirjailija = kirjailija;
          this.nimi = nimi;
          this.sivujenLukumaara = sivuja;
      }

      public Henkilo getKirjailija() {
          return this.kirjailija;
      }

      public String getNimi() {
          return this.nimi;
      }

      public int getSivujenLukumaara() {
          return this.sivujenLukumaara;
      }
  }
<% end %>

<p>
  Oletetaan, että käytössämme on lista kirjoja. Virran metodien avulla esimerkiksi kirjailijoiden syntymävuosien keskiarvon selvittäminen onnistuu luontevasti. Ensin muunnamme kirjoja sisältävän virran henkilöitä sisältäväksi virraksi, tämän jälkeen muunnamme henkilöitä sisältävän virran syntymävuosia sisältäväksi virraksi, ja lopulta pyydämme (kokonaislukuja sisältävältä) virralta keskiarvoa.
</p>

<% partial 'partials/code_highlight' do %>
  // oletetaan, että käytössämme on lista kirjoja
  // ArrayList&lt;Kirja&gt; kirjat = new ArrayList&lt;&gt;();

  double keskiarvo = kirjat.stream()
                           .map(kirja -&gt; kirja.getKirjailija())
                           .mapToInt(kirjailija -&gt; kirjailija.getSyntymavuosi())
                           .average()
                           .getAsDouble();

  System.out.println("Kirjailijoiden syntymävuosien keskiarvo: " + keskiarvo);
<% end %>


<p>
  Vastaavasti kirjojen, joiden nimessä esiintyy sana "Potter", kirjailijoiden nimet saa selville seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  // oletetaan, että käytössämme on lista kirjoja
  // ArrayList&lt;Kirja&gt; kirjat = new ArrayList&lt;&gt;();

  kirjat.stream()
        .filter(kirja -&gt; kirja.getNimi().contains("Potter"))
        .map(kirja -&gt; kirja.getKirjailija())
        .forEach(kirjailija -&gt; System.out.println(kirjailija.getEtunimi() + " " + kirjailija.getSukunimi()));
<% end %>

<p>
  Myös monimutkaisempien merkkijonoesitysten rakentaminen on virran avulla mahdollista. Alla olevassa esimerkissä tulostamme "Kirjailijan sukunimi: Kirja" -parit aakkosjärjestyksessä.
</p>

<% partial 'partials/code_highlight' do %>
  // oletetaan, että käytössämme on lista kirjoja
  // ArrayList&lt;Kirja&gt; kirjat = new ArrayList&lt;&gt;();

  kirjat.stream()
        .map(kirja -&gt; kirja.getKirjailija().getSukunimi() + ": " + kirja.getNimi())
        .sorted()
        .forEach(nimi -&gt; System.out.println(nimi));
<% end %>



<% partial 'partials/exercise', locals: { name: 'Painon laskemista (2 osaa)' } do %>

  <p>
    Tehtäväpohjassa on edellisen osan tehtävä "Tavara, Matkalaukku ja Lastiruuma". Tässä tehtävässä tarkoituksenasi on muuttaa toistolausetta käyttävät metodit virtaa käyttäviksi metodeiksi niiltä osin, kuin tämä on mahdollista. Ohjelman toiminnallisuuden tulee säilyä samana.
  </p>

  <p>
    Tässä tehtävässä ei ole erillisiä virran käyttämistä testaavista testejä. Kun toistolausetta hyödyntävät osiot on muunnettu virtaa käyttäviksi, palauta tehtävä. Tehtävä on kokonaisuudessaan kahden pisteen arvoinen.
  </p>
  
<% end %>


<% partial 'partials/exercise', locals: { name: 'Arvosanatilastot (3 osaa)' } do %>

  <p>
    Tässä tehtävässä toteutetaan ohjelma kurssipistetilastojen tulostamiseen. Ohjelmalle syötetään pisteitä (kokonaislukuja nollasta sataan), ja ohjelma tulostaa niiden perusteella arvosanoihin liittyviä tilastoja. Syötteiden lukeminen lopetetaan kun käyttäjä syöttää luvun -1. Lukuja, jotka eivät ole välillä [0-100] ei tule ottaa huomioon tilastojen laskemisessa.
  </p>

  
  <h2>Pisteiden keskiarvot</h2>

  <p>
    Kirjoita ohjelma, joka lukee käyttäjältä kurssin yhteispisteitä kuvaavia kokonaislukuja. Luvut väliltä [0-100] ovat hyväksyttäviä ja luku -1 lopettaa syötteen. Muut luvut ovat virhesyötteitä, jotka tulee jättää huomiotta. Kun käyttäjä syöttää luvun -1, tulostetaan (1) syötettyjen yhteispisteiden keskiarvo ja (2) hyväksyttyyn arvosanaan riittävien yhteispisteiden keskiarvo.
  </p>

  <p>
    Hyväksytyn arvosanan saa vähintään 71 kurssipisteellä. Voit olettaa, että käyttäjä kirjoittaa aina vähintään yhden välillä [0-100] olevan kokonaisluvun. Jos hyväksyttyyn arvosanaan osuvia lukuja ei ole lainkaan, tulostetaan viiva hyväksyttyjen keskiarvon kohdalle "-".
  </p>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">-42</font>
    <font color="red">24</font>
    <font color="red">42</font>
    <font color="red">72</font>
    <font color="red">80</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 54.0
    Pisteiden keskiarvo (hyväksytyt): 76.0
  <% end %>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">50</font>
    <font color="red">51</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 51.0
    Pisteiden keskiarvo (hyväksytyt): -
  <% end %>

  
  <h2>Hyväksyttyjen prosenttiosuus</h2>

  <p>
    Täydennä edellisessä osassa toteuttamaasi ohjelmaa siten, että ohjelma tulostaa myös hyväksymisprosentin. Hyväksymisprosentti lasketaan kaavalla <em>100 * hyväksytyt / osallistujat</em>.
  </p>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">50</font>
    <font color="red">51</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 51.0
    Pisteiden keskiarvo (hyväksytyt): -
    Hyväksymisprosentti: 0.0
  <% end %>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">102</font>
    <font color="red">-4</font>
    <font color="red">33</font>
    <font color="red">77</font>
    <font color="red">99</font>
    <font color="red">1</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 52.5
    Pisteiden keskiarvo (hyväksytyt): 88.0
    Hyväksymisprosentti: 50.0
  <% end %>


  <h2>Arvosanajakauma</h2>

  <p>
    Täydennä ohjelmaa siten, että ohjelma tulostaa myös arvosanajakauman. Arvosananajakauma muodostetaan seuraavasti.
  </p>

  <table class="table">
    
    <tr>
      <th>pistemäärä</th>
      <th>arvosana</th>
    </tr>
    
    <tr>
      <td>&lt; 70</td>
      <td>hylätty eli 0</td>
    </tr>

    <tr>
      <td>&lt; 76</td>
      <td>1</td>
    </tr>

    <tr>
      <td>&lt; 81</td>
      <td>2</td>
    </tr>

    <tr>
      <td>&lt; 86</td>
      <td>3</td>
    </tr>

    <tr>
      <td>&lt; 91</td>
      <td>4</td>
    </tr>

    <tr>
      <td>&gt;= 91</td>
      <td>5</td>
    </tr>
    
  </table>


  <p>
    Jokainen koepistemäärä muutetaan arvosanaksi yllä olevan taulukon perusteella. Jos syötetty pistemäärä ei ole välillä [0-100], jätetään se huomiotta.
  </p>

  <p>
    Arvosanajakauma tulostetaan tähtinä. Esim jos arvosanaan 5 oikeuttavia koepistemääriä on 1 kappale, tulostuu rivi <em>5: *</em>. Jos johonkin arvosanaan oikeuttavia pistemääriä ei ole, ei yhtään tähteä tulostu, alla olevassa esimerkissä näin on mm. nelosten kohdalla.</em>
  </p>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">102</font>
    <font color="red">-2</font>
    <font color="red">1</font>
    <font color="red">33</font>
    <font color="red">77</font>
    <font color="red">99</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 52.5
    Pisteiden keskiarvo (hyväksytyt): 88.0
    Hyväksymisprosentti: 50.0
    Arvosanajakauma:
    5: *
    4:
    3:
    2: *
    1:
    0: **
  <% end %>

<% end %>



<% partial 'partials/material_heading' do %>
  Tiedostot ja tiedon lukeminen
<% end %>


<p>
  Merkittävä osa ohjelmistoista perustuu tavalla tai toisella tiedon käsittelyyn. Musiikin toistoon tarkoitetut ohjelmistot käsittelevät musiikkitiedostoja, kuvankäsittelyohjelmat käsittelevät kuvatiedostoja. Verkossa ja mobiililaitteissa toimivat sovellukset kuten Facebook ja WhatsApp taas käsittelevät muunmuassa tietokantoihin tallennettuja henkilötietoja. Kaikissa näistä sovelluksista on yhteistä tiedon lukeminen, tiedon käsitteleminen tavalla tai toisella sekä se, että käsiteltävä tieto on loppujenlopulta tallennettu jonkinlaisessa muodossa yhteen tai useampaan tiedostoon.
</p>

<p>
  Tutustutaan seuraavaksi tiedostoihin sekä erilaisiin tapoihin tiedon lukemiseen. Ensin käsite tiedosto tulee ehkäpä hieman tutummaksi. Tämän jälkeen käsittelemme jo tutuksi tullutta näppäimistöltä lukemista osana tekstikäyttöliittymää, jonka jälkeen tutustumme tiedon lukemiseen tiedostosta. Tämän jälkeen käsittelemme lyhyesti myös tiedon hakemista verkkoyhteyden yli. Tiedon lukeminen tietokannoista sekä tiedon lukeminen ja käsittely osana graafista käyttöliittymää tulee tutuksi ohjelmoinnin jatkokurssilla.
</p>


<% partial 'partials/hint', locals: { name: 'Tiedoston sijainti' } do %>

  <p>
    Voit käydä tarkastelemassa NetBeansissa kaikkia projektiin liittyviä tiedostoja valitsemalla <code>Files</code>-välilehden. Jos tiedosto on projektin juuressa, saa sen auki File-olion avulla vain nimen perusteella. Jos taas tiedosto on jossain muualla, tulee myös sen polku kertoa.
  </p>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Uuden tiedoston luominen' } do %>

  <p>
    Tässä tehtävässä ei ohjelmoida, vaan tutustutaan tiedoston luomiseen.
  </p>
  
  <p>
    Luo tehtäväpohjan juurikansioon (samassa kansiossa mm. kansiot <code>src</code> ja <code>test</code>) tiedosto nimeltä <code>tiedosto.txt</code>. Muokkaa tiedostoa, ja kirjoita tiedoston ensimmäisen rivin alkuun viesti <code>Hei maailma</code>. 
  </p>
  
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Lukeminen näppäimistöltä
<% end %>

<p>
  Olemme käyttäneet Scanner-luokkaa näppäimistöllä kirjoitetun syötteen lukemiseen kurssin alusta lähtien. Tyypillinen tiedon lukemiseen käytetty runko on ollut while-true -toistolause, missä lukeminen lopetetaan tiettyyn käyttäjän kirjoittamaan merkkiin tai merkkijonoon.
</p>

<% partial 'partials/code_highlight' do %>
// luodaan Scanner-olio, joka lukee näppäimistösyötettä
Scanner lukija = new Scanner(System.in);

// jatketaan syötteen lukemista kunnes käyttäjä syöttää
// rivin "loppu"
while (true) {
    String rivi = lukija.nextLine();

    if (rivi.equals("loppu")) {
        break;
    }

    // lisää luettu rivi myöhempää käsittelyä varten
    // tai käsittele rivi
}

// käsittele myöhempää käsittelyä varten lisätyt rivit
<% end %>

<p>
  Yllä Scanner-luokan konstruktorille annetaan parametrina järjestelmän syöte (<code>System.in</code>). Tekstikäyttöliittymissä käyttäjän kirjoittama tieto ohjataan syötevirtaan rivi kerrallaan, eli tieto lähetetään käsiteltäväksi aina kun käyttäjä painaa rivinvaihtoa.
</p>


<% partial 'partials/material_sub_heading' do %>
  Lukeminen tiedostosta
<% end %>

<p>
  Tiedostot ovat tietokoneella sijaitsevia tietokokoelmia, jotka voivat sisältää vaikkapa tekstiä, kuvia, musiikkia tai niiden yhdistelmiä. Tiedoston tallennusmuoto määrittelee tiedoston sisällön sekä tavan tiedon lukemiseen. Esimerkiksi PDF-tiedostoja luetaan PDF-tiedostojen lukemiseen soveltuvalla ohjelmalla ja musiikkitiedostoja luetaan musiikkitiedostojen lukemiseen soveltuvalla ohjelmalla. Jokainen näistä ohjelmista on ihmisen luoma, ja ohjelman luoja tai luojat -- eli ohjelmoijat -- ovat osana työtään myös määritelleet tiedoston tallennusmuodon.
</p>

<p>
  Tiedoston lukeminen tapahtuu Javan valmiin <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html" target="_blank" rel="noopener">Files</a>-apukirjaston avulla. Apukirjaston tarjoaman metodin <code>lines</code> avulla tiedostosta voidaan luoda syötevirta, jonka käsittely onnistuu edellä tutuiksi tulleilla menetelmillä. Metodi <code>lines</code> saa patametrikseen polun, joka luodaan apukirjaston <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html" target="_blank" rel="noopener">Paths</a> tarjoamalla metodilla <code>get</code>, jolle annetaan parametrina tiedostopolkua kuvaava merkkijono.
</p>

<p>
  Alla olevassa esimerkissä luetaan tiedoston "tiedosto.txt" kaikki rivit, jotka lisätään ArrayList-listaan. Tiedostoja lukiessa voidaan kohdata virhetilanne, joten tiedoston lukeminen vaatii erillisen "yrittämisen" (try) sekä mahdollisen virheen kiinnioton (catch). Palaamme virhetilanteiden käsittelyyn ohjelmoinnin jatkokurssilla.
</p>

<% partial 'partials/code_highlight' do %>
ArrayList&lt;String&gt; rivit = new ArrayList&lt;&gt;();

try {
    Files.lines(Paths.get("tiedosto.txt")).forEach(rivi -&gt rivit.add(rivi));
} catch (Exception e) {
    System.out.println("Virhe: " + e.getMessage());
}

// tee jotain luetuilla riveillä
<% end %>


<p>
  Jos tiedosto löytyy ja sen lukeminen onnistuu, tulee ohjelman suorituksen lopussa tiedoston "tiedosto.txt" rivit olemaan listamuuttujassa <code>rivit</code>. Jos taas tiedostoa ei löydy, tai sen lukeminen epäonnistuu, ilmoitetaan tästä virheviestillä. Alla eräs mahdollisuus:
</p>

<% partial 'partials/sample_output' do %>
Virhe: tiedosto.txt (No such file or directory)
<% end %>


<p>
  Edellä mainitun lähestymistavan lisäksi tiedoston lukemiseen voi käyttää myös tutuksi tullutta Scanner-luokkaa. Scanner-luokan konstruktorille voi antaa parametrina myös tiedosto-olion, jolloin Scanner-oliota käytetään kyseisen tiedoston sisällön lukemiseen. Lukeminen tapahtuu while-toistolauseella, jota jatketaan niin pitkään kuin Scanner-olion käsittelemässä tiedostossa on vielä lukemattomia rivejä jäljellä.
</p>



<% partial 'partials/code_highlight' do %>
ArrayList&lt;String&gt; rivit = new ArrayList&lt;&gt;();

// luodaan lukija tiedoston lukemista varten
try (Scanner lukija = new Scanner(new File("tiedosto.txt"))) {

    // luetaan kaikki tiedoston rivit
    while (lukija.hasNextLine()) {
        rivit.add(lukija.nextLine());
    }
} catch (Exception e) {
    System.out.println("Virhe: " + e.getMessage());
}

// tee jotain luetuilla riveillä
<% end %>


<% partial 'partials/exercise', locals: { name: 'Löytyykö tiedostosta?' } do %>

  <p>
    Tehtäväpohjassa tulee kaksi tekstitiedostoa: <code>nimet.txt</code> ja <code>toiset-nimet.txt</code>. Kirjoita ohjelma, joka kysyy ensin käyttäjältä luettavan tiedoston nimeä, jonka jälkeen käyttäjältä kysytään etsittävää merkkijonoa. Tämän jälkeen ohjelma lukee tiedoston ja etsii tiedostosta haluttua merkkijonoa.
  </p>

  <p>
    Jos merkkijono löytyy, ohjelman tulee tulostaa "Löytyi!". Jos merkkijonoa ei löydy, ohjelman tulee tulostaa "Ei löytynyt.". Jos tiedoston lukeminen epäonnistuu (lukeminen päätyy virhetilanteeseen), ohjelman tulee tulostaa viesti "Tiedoston lukeminen epäonnistui.".
  </p>

  <% partial 'partials/sample_output' do %>
Minkä niminen tiedosto luetaan?
<font color="red">nimet.txt</font>
Mitä etsitään?
<font color="red">Antti</font>
Ei löytynyt.
  <% end %>

  <% partial 'partials/sample_output' do %>
Minkä niminen tiedosto luetaan?
<font color="red">nimet.txt</font>
Mitä etsitään?
<font color="red">ada</font>
Löytyi!
  <% end %>

  <% partial 'partials/sample_output' do %>
Minkä niminen tiedosto luetaan?
<font color="red">olematon.txt</font>
Mitä etsitään?
<font color="red">testi</font>
Tiedoston olematon.txt lukeminen epäonnistui.
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Vieraslista tiedostosta' } do %>


  <p>
    Tehtäväpohjassa on valmiina toiminnallisuus vieraslistaohjelmaan, missä käyttäjän syöttämien nimien olemassaolo tarkistetaan vieraslistalta.
  </p>

  <p>
    Ohjelmasta puuttuu kuitenkin toiminnallisuus vieraslistan lukemiseen. Muokkaa ohjelmaa siten, että vieraslistan nimet luetaan tiedostosta.
  </p>

  <% partial 'partials/sample_output' do %>
Minkä niminen tiedosto luetaan?
<font color="red">vieraslista.txt</font>

Syötä nimiä, tyhjä rivi lopettaa.
<font color="red">Chuck Norris</font>
Nimi ei ole listalla.
<font color="red">Jack Baluer</font>
Nimi ei ole listalla.
<font color="red">Jack Bauer</font>
Nimi on listalla.
<font color="red">Jack Bower</font>
Nimi on listalla.

Kiitos!
  <% end %>


  <p>
    Huom! Tehtäväpohjassa on mukana kaksi tiedostoa, <code>nimet.txt</code> ja <code>toiset-nimet.txt</code>, joiden sisällöt ovat seuravat. Älä muuta näiden tiedostojen sisältöä!
  </p>

  <p>
    nimet.txt:
  </p>

  <% partial 'partials/sample_output' do %>
ada
arto
leena
testi
  <% end %>

  <p>
    toiset-nimet.txt:
  </p>

  <% partial 'partials/sample_output' do %>
leo
jarmo
alicia
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Desibelimittaukset tiedostosta' } do %>

  <p>
    Toteuta ohjelma, joka lukee käyttäjältä tiedoston nimen sekä hyväksyttävien lukujen ala- ja ylärajan. Tämän jälkeen ohjelma lukee tiedoston sisältämät luvut (jokainen luku on omalla rivillään) ja ottaa huomioon vain ne luvut, jotka ovat annetulla lukuvälillä. Lopulta ohjelma tulostaa annetulla lukuvälillä olleiden lukujen lukumäärän.
  </p>

  <% partial 'partials/sample_output' do %>
Tiedosto? <font color="red">mittaukset-1.txt</font>
Alaraja? <font color="red">15</font>
Yläraja? <font color="red">20</font>
Lukuja: 2
  <% end %>

  <% partial 'partials/sample_output' do %>
Tiedosto? <font color="red">mittaukset-1.txt</font>
Alaraja? <font color="red">0</font>
Yläraja? <font color="red">300</font>
Lukuja: 4
  <% end %>

  <p>
    Huom! Tehtäväpohjassa on mukana kaksi tiedostoa, <code>mittaukset-1.txt</code> ja <code>mittaukset-2.txt</code>, joiden sisällöt ovat seuravat. Älä muuta näiden tiedostojen sisältöä.
  </p>

  <p>mittaukset-1.txt:</p>

  <% partial 'partials/sample_output' do %>
300
9
20
15
  <% end %>

  <p>mittaukset-2.txt:</p>

  <% partial 'partials/sample_output' do %>
123
-5
12
67
-300
1902
  <% end %>

<% end %>



<% partial 'partials/material_sub_heading' do %>
  Lukeminen verkkoyhteyden yli
<% end %>

<p>
  Lähes kaikki verkkosivut, kuten tämäkin oppimateriaali, voidaan lukea tekstimuodossa ohjelmallista käsittelyä varten. Scanner-oliolle voi antaa konstruktorin parametrina lähes minkälaisen syötevirran tahansa. Alla olevassa esimerkissä luodaan URL-olio annetusta web-osoitteesta, pyydetään siihen liittyvää tietovirtaa, ja annetaan se uudelle Scanner-oliolle luettavaksi.
</p>


<% partial 'partials/code_highlight' do %>
ArrayList&lt;String&gt; rivit = new ArrayList&lt;&gt;();

// luodaan lukija web-osoitteen lukemista varten
try (Scanner lukija = new Scanner(new URL("http://www.cs.helsinki.fi/home/").openStream())) {
  
    // luetaan osoitteesta http://www.cs.helsinki.fi/home/
    // saatava vastaus
    while (lukija.hasNextLine()) {
        rivit.add(lukija.nextLine());
    }
} catch (Exception e) {
    System.out.println("Virhe: " + e.getMessage());
}

// tehdään jotain vastauksella
<% end %>

<p>
  Web-selain on oikeastaan ohjelma siinä missä muutkin ohjelmat. Toisin kuin yllä toteutettu sivun sisällön lataaja, web-selaimeen on toteutettu toiminnallisuus vastauksena tulevan HTML-muotoisen lähdekoodin tulkisemiseen ja graafisessa käyttöliittymässä näyttämiseen.
</p>

<% partial 'partials/exercise', locals: { name: 'Chuck Norris -vitsit' } do %>

  <p>
    Osoitteessa <a href="http://www.icndb.com/api/" target="_blank" rel="noopener">http://www.icndb.com/api/</a> sijaitsee web-sovellus, joka tarjoaa Chuck Norris -vitsejä kaikkien vapaaseen käyttöön.
  </p>

  <p>
    Sovellus tarjoaa muunmuassa mahdollisuuden satunnaisten vitsien hakemiseen (osoite <code>http://api.icndb.com/jokes/random</code>) sekä vitsien hakemiseen niihin liittyvillä numeerisilla tunnuksilla (osoite <code>http://api.icndb.com/jokes/<em>tunnus</em></code>, missä <em>tunnus</em> on kokonaisluku).
  </p>

  <p>
    Toteuta sovellus, joka tarjoaa kolme toimintoa. Jos käyttäjä kirjoittaa "lopeta", ohjelman suoritus lopetetaan. Jos käyttäjä kirjoittaa "satunnainen", ohjelma tulostaa icndb-palvelusta noudetun satunnaisen chuck norris vitsin. Jos käyttäjä kirjoittaa "vitsi <em>numero</em>", missä numero on kokonaisluku, ohjelma tulostaa icndb-palvelusta noudetun tietyn vitsin.
  </p>

  <p>
    Huom! Tässä tehtävässä riittää tulostaa palvelun palauttama merkkijono kokonaisuudessaan. Merkkijono voi olla esimerkiksi muotoa <code>{ "type": "success", "value": { "id": 341, "joke": "Chuck Norris sleeps with a pillow under his gun.", "categories": [] } }</code>.
  </p>

  <p>
    Ohjelmassa ei ole testejä, eli testit eivät ota kantaa sovelluksen rakenteeseen tai tulostuksen ulkoasuun. Palauta sovellus kun se toimii koneellasi toivotulla tavalla.
  </p>

<% end %>




<% partial 'partials/material_heading' do %>
  Hajautustaulu (HashMap)
<% end %>


<p>
  <a href="http://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">Hajautustaulu</a> on eräs ohjelmoinnissa paljon käytetyistä tietorakenteista. Hajautustaulua käytetään kun halutaan käsitellä tietoa avain-arvo -pareina, missä avaimen perusteella voidaan lisätä, hakea ja poistaa avaimeen liittyvä arvo.
</p>

<p>
  Alla olevassa esimerkissä on luotu HashMap-olio kaupunkien hakemiseen postinumeron perusteella, jonka jälkeen HashMap-olioon on lisätty neljä postinumero-kaupunki -paria. Sekä postinumero että kaupunki on esitetty merkkijonona.
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, String&gt; postinumerot = new HashMap&lt;&gt;();
  postinumerot.put("00710", "Helsinki");
  postinumerot.put("90014", "Oulu");
  postinumerot.put("33720", "Tampere");
  postinumerot.put("33014", "Tampere");
<% end %>

<img src="/img/drawings/hashmap.png" alt="Hashmapissa avaimen perusteella saadaan selville arvo."/>

<p>
  Hajautustaulua luodessa tarvitaan kaksi tyyppiparametria, avainmuuttujan tyyppi ja lisättävän arvon tyyppi. Kuten yllä, myös seuraavassa esimerkissä sekä avainmuuttujan että lisättävän arvon tyyppi on String.
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, String&gt; numerot = new HashMap&lt;&gt;();
  numerot.put("Yksi", "Uno");
  numerot.put("Kaksi", "Dos");

  String kaannos = numerot.get("Yksi");
  System.out.println(kaannos);

  System.out.println(numerot.get("Kaksi"));
  System.out.println(numerot.get("Kolme"));
  System.out.println(numerot.get("Uno"));
<% end %>

<% partial 'partials/sample_output' do %>
  Uno
  Dos
  null
  null
<% end %>


<p>
  Yllä olevassa esimerkissä luodaan hajatustaulu, jonka avaimena ja tallennettavana oliona on merkkijono. Hajautustauluun lisätään tietoa kaksiparametrisella metodilla <code>put</code>, jolle annetaan parametrina sekä avain- että arvomuuttuja.
</p>

<p>
  Yksiparametrinen metodi <code>get</code> palauttaa parametrina annettuun avaimeen liittyvän viitteen tai <code>null</code>-viitteen jos avaimella ei löydy viitettä.
</p>

<%= partial 'partials/quiz', locals: { id: '59da5a594538e90004e0f0e7' } %>


<p>
  Hajautustaulussa on jokaista avainta kohden korkeintaan yksi arvo. Jos hajautustauluun lisätään uusi avain-arvo -pari, missä avain on jo aiemmin liittynyt toiseen hajautustauluun tallennettuun arvoon, vanha arvo katoaa hajautustaulusta.
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, String&gt; numerot = new HashMap&lt;&gt;();
  numerot.put("Uno", "Yksi");
  numerot.put("Dos", "Zwei");
  numerot.put("Uno", "Ein");

  String kaannos = numerot.get("Uno");
  System.out.println(kaannos);

  System.out.println(numerot.get("Dos"));
  System.out.println(numerot.get("Tres"));
  System.out.println(numerot.get("Uno"));
<% end %>

<% partial 'partials/sample_output' do %>
  Ein
  Zwei
  null
  Ein
<% end %>


<% partial 'partials/exercise', locals: { name: 'Lempinimet' } do %>

  <p>
    Luo <code>main</code>-metodissa uusi <code>HashMap&lt;String,String&gt;</code>-olio. Tallenna luomaasi olioon seuraavien henkilöiden nimet ja lempinimet niin, että nimi on avain ja lempinimi on arvo. Käytä pelkkiä pieniä kirjaimia.
  </p>

  <ul>
    <li>matin lempinimi on mage</li>
    <li>mikaelin lempinimi on mixu</li>
    <li>arton lempinimi on arppa</li>
  </ul>

  <p>
    Tämän jälkeen hae HashMapistä mikaelin lempinimi ja tulosta se.
  </p>

  <p>
    Testit edellyttävät että kirjoitat nimet pienellä alkukirjaimella.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Viittaustyyppinen muuttuja hajautustaulussa
<% end %>

<p>
  Tutkitaan hajautustaulun toimintaa kirjastoesimerkin avulla. Kirjastosta voi hakea kirjoja kirjan nimen perusteella. Jos haetulla nimellä löytyy kirja, palauttaa kirjasto kirjan viitteen. Luodaan ensin esimerkkiluokka <code>Kirja</code>, jolla on oliomuuttujina nimi, kirjaan liittyvä sisältö sekä kirjan julkaisuvuosi.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kirja {
      private String nimi;
      private String sisalto;
      private int julkaisuvuosi;

      public Kirja(String nimi, int julkaisuvuosi, String sisalto) {
          this.nimi = nimi;
          this.julkaisuvuosi = julkaisuvuosi;
          this.sisalto = sisalto;
      }

      public String getNimi() {
          return this.nimi;
      }

      public void setNimi(String nimi) {
          this.nimi = nimi;
      }

      public int getJulkaisuvuosi() {
          return this.julkaisuvuosi;
      }

      public void setJulkaisuvuosi(int julkaisuvuosi) {
          this.julkaisuvuosi = julkaisuvuosi;
      }

      public String getSisalto() {
          return this.sisalto;
      }

      public void setSisalto(String sisalto) {
          this.sisalto = sisalto;
      }

      public String toString() {
          return "Nimi: " + this.nimi + " (" + this.julkaisuvuosi + ")\n"
              + "Sisältö: " + this.sisalto;
      }
  }
<% end %>

<p>
  Luodaan seuraavaksi hajautustaulu, joka käyttää avaimena kirjan nimeä eli String-tyyppistä oliota, ja arvona edellä luomaamme kirjaa.
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, Kirja&gt; hakemisto = new HashMap&lt;&gt;();
<% end %>

<p>
  Yllä oleva hajautustaulu käyttää avaimena <code>String</code>-oliota. Laajennetaan esimerkkiä siten, että hakemistoon lisätään kaksi kirjaa, <code>"Järki ja tunteet"</code> ja <code>"Ylpeys ja ennakkoluulo"</code>.
</p>

<% partial 'partials/code_highlight' do %>
  Kirja jarkiJaTunteet = new Kirja("Järki ja tunteet", 1811, "...");
  Kirja ylpeysJaEnnakkoluulo = new Kirja("Ylpeys ja ennakkoluulo", 1813, "....");

  HashMap&lt;String, Kirja&gt; hakemisto = new HashMap&lt;&gt;();
  hakemisto.put(jarkiJaTunteet.getNimi(), jarkiJaTunteet);
  hakemisto.put(ylpeysJaEnnakkoluulo.getNimi(), ylpeysJaEnnakkoluulo);
<% end %>

<p>
  Hakemistosta voi hakea kirjoja kirjan nimellä. Haku kirjalla <code>"Viisasteleva sydän"</code> ei tuota osumaa, jolloin hajautustaulu palauttaa <code>null</code>-viitteen. Kirja "Ylpeys ja ennakkoluulo" kuitenkin löytyy.
</p>

<% partial 'partials/code_highlight' do %>
  Kirja kirja = hakemisto.get("Viisasteleva sydän");
  System.out.println(kirja);
  System.out.println();
  kirja = hakemisto.get("Ylpeys ja ennakkoluulo");
  System.out.println(kirja);
<% end %>

<% partial 'partials/sample_output' do %>
  null

  Nimi: Ylpeys ja ennakkoluulo (1813)
  Sisältö: ...
<% end %>

<p>
  Hajautustauluun lisättäessä avain-arvo -parin arvo voi olla käytännössä mitä tahansa. Arvo voi olla kokonaisluku, lista, tai vaikkapa toinen hajautustaulu.
</p>

<%= partial 'partials/quiz', locals: { id: '59da5b104538e90004e0f0e8' } %>


<% partial 'partials/material_sub_heading' do %>
  Hajautustaulu oliomuuttujana
<% end %>

<p>
  Edellä kuvatun esimerkin ongelma on se, että kirjan kirjoitusmuoto tulee muistaa täsmälleen oikein. Joku saattaa etsiä kirjaa pienellä alkukirjaimella ja joku toinen saattaa vaikkapa painaa välilyöntiä nimen kirjoituksen aluksi. Tarkastellaan seuraavaksi erästä tapaa hieman sallivampaan kirjan nimen perusteella tapahtuvaan hakemiseen.
</p>

<p>
  Hyödynnämme hakemisessa String-luokan tarjoamia välineitä merkkijonojen käsittelyyn. Metodi <code>toLowerCase()</code> luo merkkijonosta uuden merkkijonon, jonka kaikki kirjaimet on muunnettu pieniksi. Metodi <code>trim()</code> taas luo merkkijonosta uuden merkkijonon, jonka alusta ja lopusta on poistettu tyhjät merkit kuten välilyönnit.
</p>

<% partial 'partials/code_highlight' do %>
  String teksti = "Ylpeys ja ennakkoluulo ";
  teksti = teksti.toLowerCase(); // teksti nyt "ylpeys ja ennakkoluulo "
  teksti = teksti.trim() // teksti nyt "ylpeys ja ennakkoluulo"
<% end %>

<p>
  Jos mietit "<em>kuka kirjoittaisi välilyöntejä ja miksi?</em>", etsi ja lue kirja <a href="https://en.wikipedia.org/wiki/Ender's_Game" target="_blank" rel="noopener">Ender's Game</a> (suom. Ender).
</p>

<p>
  Luodaan luokka <code>Kirjasto</code>, joka kapseloi kirjat sisältävän hajautustaulun ja mahdollistaa kirjoitusasusta riippumattoman kirjojen haun. Lisätään luokalle <code>Kirjasto</code> metodit lisäämiseen, hakemiseen ja poistamiseen. Jokainen näistä tapahtuu siistityn nimen perusteella -- siistiminen sisältää nimen muuntamisen pienellä kirjoitetuksi sekä ylimääräisten alussa ja lopussa olevien välilyöntien poistamisen.
</p>

<p>
  Huomaamme jo nyt että merkkijonon siistimiseen liittyvää koodia tarvitsisi jokaisessa kirjaa käsittelevässä metodissa, joten siitä on hyvä tehdä erillinen metodi.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kirjasto {
      private HashMap&lt;String, Kirja&gt; hakemisto;

      public Kirjasto() {
          this.hakemisto = new HashMap&lt;&gt;();
      }

      public void lisaaKirja(Kirja kirja) {
          String nimi = siistiMerkkijono(kirja.getNimi());

          if (this.hakemisto.containsKey(nimi)) {
              System.out.println("Kirja on jo kirjastossa!");
          } else {
              hakemisto.put(nimi, kirja);
          }
      }

      public Kirja haeKirja(String kirjanNimi) {
          kirjanNimi = siistiMerkkijono(kirjanNimi);
          return this.hakemisto.get(kirjanNimi);
      }

      public void poistaKirja(String kirjanNimi) {
          kirjanNimi = siistiMerkkijono(kirjanNimi);

          if (this.hakemisto.containsKey(kirjanNimi)) {
              this.hakemisto.remove(kirjanNimi);
          } else {
              System.out.println("Kirjaa ei löydy, ei voida poistaa!");
          }
      }

      public String siistiMerkkijono(String merkkijono) {
          if (merkkijono == null) {
              return "";
          }

          merkkijono = merkkijono.toLowerCase();
          return merkkijono.trim();
      }
  }
<% end %>

<p>
  Yllä käytetään hajautustaulun tarjoamaa metodia <code>containsKey</code> avaimen olemassaolon tarkastamiseen. Metodi palauttaa arvon <code>true</code>, jos hajautustauluun on lisätty haetulla avaimella mikä tahansa arvo, muulloin metodi palauttaa arvon <code>false</code>.
</p>

<p>
  Edeltävässä esimerkissä noudatimme ns. DRY-periaatetta (Don't Repeat Yourself), jonka tarkoituksena on saman koodin toistumisen välttäminen. Merkkijonon siistiminen eli pienellä kirjoitetuksi muuttaminen sekä <em>trimmaus</em>, eli tyhjien merkkien poisto alusta ja lopusta, olisi toistunut useasti kirjastoluokassamme ilman metodia <code>siistiMerkkijono</code>. Toistuvaa koodia ei usein huomaa ennen kuin sitä on jo kirjoittanut, jolloin sitä päätyy koodiin lähes pakosti. Tässä ei ole mitään pahaa -- tärkeintä on että koodia siistitään sitä mukaa siistimistä vaativia tilanteita huomataan.
</p>

<% partial 'partials/material_sub_heading' do %>
  Hajautustaulun arvojen läpikäynti
<% end %>

<p>
  Hajautustaulun avain-arvo -parien läpikäynti onnistuu metodin <code>entrySet()</code> avulla. Metodi <code>entrySet()</code> palauttaa hajautustaulussa olevat avain-arvo -parit tietokokoelmana, jonka voi käsitellä virtana. Yksittäinen arvo sisältää metodit <code>getKey()</code>, jolla saa avain-arvo -parin avaimen, ja <code>getValue()</code>, jolla saa avain-arvo -parin arvon.
</p>

<p>
  Tarkastellaan tätä kirjastoesimerkin kautta.
</p>

<p>
  Haluamme joskus etsiä kirjaa nimen osan perusteella. Hajautustaulun metodi <code>get</code> ei tähän sovellu, sillä sitä käytetään tietyllä avaimella etsimiseen. Kirjan nimen osan perusteella etsiminen onnistuu entrySet-metodin palauttamasta joukosta.
</p>

<p>
  Alla olevassa esimerkissä haetaan kaikki ne kirjat, joiden nimessä esiintyy annettu merkkijono.
</p>

<% partial 'partials/code_highlight' do %>
  public ArrayList&lt;Kirja&gt; haeKirjaNimenOsalla(String nimenOsa) {
      nimenOsa = siistiMerkkijono(nimenOsa);

      // haetaan kaikki ne kirjan nimet, joissa esiintyy nimen osa,
      // ja noudetaan niihin liittyvät kirjat
      ArrayList&lt;Kirja&gt; kirjat = this.hakemisto.entrySet()
                                    .stream()
                                    .filter(entry -&gt; entry.getKey().contains(nimenOsa))
                                    .map(entry -&gt; entry.getValue())
                                    .collect(Collectors.toCollection(ArrayList::new));
  }
<% end %>

<p>
  Tällä tavalla etsiessä menetämme kuitenkin hajautustauluun liittyvän nopeusedun. Hajautustaulu on toteutettu siten, että yksittäisen avaimen perusteella hakeminen erittäin nopeaa. Yllä olevassa esimerkissä käydään kaikkien kirjojen nimet läpi, kun tietyllä avaimella etsittäessä tarkasteltaisiin tasan yhden kirjan olemassaoloa.
</p>


<% partial 'partials/material_sub_heading' do %>
  Alkeistyyppiset muuttujat hajautustaulussa
<% end %>

<p>
  Hajautustaulu olettaa, että siihen lisätään viittaustyyppisiä muuttujia (samoin kuin ArrayList). Java muuntaa alkeistyyppiset muuttujat viittaustyyppisiksi käytännössä kaikkia Javan valmiita tietorakenteita (kuten ArrayList ja HashMap) käytettäessä. Vaikka luku <code>1</code> voidaan esittää alkeistyyppisen muuttujan <code>int</code> arvona, tulee sen tyypiksi määritellä <code>Integer</code> ArrayListissä ja HashMapissa.
</p>


<% partial 'partials/code_highlight' do %>
  HashMap&lt;Integer, String&gt; taulu = new HashMap&lt;&gt;(); // toimii
  taulu.put(1, "Ole!");
  HashMap&lt;int, String&gt; taulu2 = new HashMap&lt;&gt;(); // ei toimi
<% end %>

<p>
  Hajautustaulun avain ja tallennettava olio ovat aina viittaustyyppisiä muuttujia. Jos haluat käyttää alkeistyyppisiä muuttujia avaimena tai tallennettavana arvona, on niille olemassa viittaustyyppiset vastineet. Alla on esitelty muutama.
</p>

<table class="table">

  <tr>
    <th>Alkeistyyppi</th>
    <th>Viittaustyyppinen vastine</th>
  </tr>
  
  <tr>
    <td>int</td>
    <td><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html" target="_blank" rel="noopener">Integer</a>
    </td>
  </tr>
  
  <tr>
    <td>double</td>
    <td><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Double.html" target="_blank" rel="noopener">Double</a></td>
  </tr>

  <tr>
    <td>char</td>
    <td><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Character.html" target="_blank" rel="noopener">Character</a></td>
  </tr>
</table>


<p>
  Java muuntaa alkeistyyppiset muuttujat automaattisesti viittaustyyppisiksi kun niitä lisätään HashMapiin tai ArrayListiin. Tätä automaattista muunnosta viittaustyyppisiksi kutsutaan Javassa <em>auto-boxingiksi</em>, eli automaattiseksi "laatikkoon" asettamiseksi. Automaattinen muunnos onnistuu myös toiseen suuntaan.
</p>

<% partial 'partials/code_highlight' do %>
  int avain = 2;
  HashMap&lt;Integer, Integer&gt; taulu = new HashMap&lt;&gt;();
  taulu.put(avain, 10);
  int arvo = taulu.get(avain);
  System.out.println(arvo);
<% end %>

<% partial 'partials/sample_output' do %>
  10
<% end %>

<p>
  Seuraava esimerkki kuvaa rekisterinumeroiden bongausten laskemiseen käytettävää luokkaa. Metodeissa metodeissa <code>lisaaBongaus</code> ja <code>montakoKertaaBongattu</code> tapahtuu automaattinen tyyppimuunnos.
</p>


<% partial 'partials/code_highlight' do %>
  public class Rekisteribongauslaskuri {
      private HashMap&lt;String, Integer&gt; bongatut;

      public Rekisteribongauslaskuri() {
          this.bongatut = new HashMap&lt;&gt;();
      }

      public void lisaaBongaus(String bongattu) {
          if (!this.bongatut.containsKey(bongattu)) {
              this.bongatut.put(bongattu, 0);
          }

          int montakobongausta = this.bongatut.get(bongattu);
          montakobongausta++;
          this.bongatut.put(bongattu, montakobongausta);
      }

      public int montakoKertaaBongattu(String bongattu) {
          this.bongatut.get(bongattu);
      }
  }
<% end %>

<p>
  Tyyppimuunnoksissa piilee kuitenkin vaara. Jos yritämme muuntaa null-viitettä -- eli esimerkiksi bongausta, jota ei ole HashMapissa -- kokonaisluvuksi, näemme virheen <em>java.lang.reflect.InvocationTargetException</em>. Kun teemme automaattista muunnosta, tulee varmistaa että muunnettava arvo ei ole null. Yllä olevassa ohjelmassa oleva <code>montakoKertaaBongattu</code>-metodi tulee korjata esimerkiksi seuraavasti.
</p>


<% partial 'partials/code_highlight' do %>
  public int montakoKertaaBongattu(String bongattu) {
      return this.bongatut.getOrDefault(bongattu, 0);
  }
<% end %>

<p>
  HashMapin metodi <code>getOrDefault</code> hakee sille ensimmäisenä parametrina annettua avainta HashMapista. Jos avainta ei löydy, palauttaa se toisena parametrina annetun arvon. Metodin toiminta vastaa seuraavaa metodia.
</p>

<% partial 'partials/code_highlight' do %>
  public int montakoKertaaBongattu(String bongattu) {
      if (this.bongatut.containsKey(bongattu) {
          return this.bongatut.get(bongattu);
      }

      return 0;
  }
<% end %>

<p>
  Siistitään vielä lisaaBongaus-metodia hieman. Alkuperäisessä versiossa metodin alussa lisätään hajautustauluun bongausten lukumääräksi arvo 0, jos bongattua ei löydy. Tämän jälkeen bongausten määrä haetaan, sitä kasvatetaan yhdellä, ja vanha bongausten lukumäärä korvataan lisäämällä arvo uudestaan hajautustauluun. Osan tästäkin toiminnallisuudesta voi korvata metodilla getOrDefault.
</p>


<% partial 'partials/code_highlight' do %>
  public class Rekisteribongauslaskuri {
      private HashMap&lt;String, Integer&gt; bongatut;

      public Rekisteribongauslaskuri() {
          this.bongatut = new HashMap&lt;&gt;();
      }

      public void lisaaBongaus(String bongattu) {
          int montakobongausta = this.bongatut.getOrDefault(bongattu, 0);
          montakobongausta++;
          this.bongatut.put(bongattu, montakobongausta);
      }

      public int montakoKertaaBongattu(String bongattu) {
          return this.bongatut.getOrDefault(bongattu, 0);
      }
  }
<% end %>



<% partial 'partials/exercise', locals: { name: 'Velkakirja' } do %>

  <p>
    Luo luokka <code>Velkakirja</code>, jolla on seuraavat toiminnot:
  </p>

  <ul>
    <li>konstruktori <code>public Velkakirja()</code> luo uuden velkakirjan</li>
    <li>metodi <code>public void asetaLaina(String kenelle, double maara)</code> tallettaa velkakirjaan merkinnän lainasta tietylle henkilölle.</li>
    <li>metodi <code>public double paljonkoVelkaa(String kuka)</code> palauttaa velan määrän annetun henkilön nimen perusteella. Jos henkilöä ei löydy, palautetaan 0.</li>
  </ul>

  <p>Luokkaa käytetään seuraavalla tavalla:</p>

  <% partial 'partials/code_highlight' do %>
    Velkakirja matinVelkakirja = new Velkakirja();
    matinVelkakirja.asetaLaina("Arto", 51.5);
    matinVelkakirja.asetaLaina("Mikael", 30);

    System.out.println(matinVelkakirja.paljonkoVelkaa("Arto"));
    System.out.println(matinVelkakirja.paljonkoVelkaa("Joel"));
  <% end %>

  <p>Yllä oleva esimerkki tulostaisi:</p>

  <% partial 'partials/sample_output' do %>
    51.5
    0.0
  <% end %>

  <p>
    Ole tarkkana tilanteessa, jossa kysytään velattoman ihmisen velkaa.
  </p>

  <p>
    Huom! Velkakirjan ei tarvitse huomioida vanhoja lainoja. Kun asetat uuden velan henkilölle jolla on vanha velka, vanha velka unohtuu.
  </p>

  <% partial 'partials/code_highlight' do %>
    Velkakirja matinVelkakirja = new Velkakirja();
    matinVelkakirja.asetaLaina("Arto", 51.5);
    matinVelkakirja.asetaLaina("Arto", 10.5);

    System.out.println(matinVelkakirja.paljonkoVelkaa("Arto"));
  <% end %>

  <% partial 'partials/sample_output' do %>
    10.5
  <% end %>

<% end %>




<% partial 'partials/material_heading' do %>
  Ohjelmien rakenteesta
<% end %>

<p>
  Kuudennen osan lopuksi muutama sana lähdekoodin kommentoinnista sekä ymmärrettävyydestä.
</p>

<% partial 'partials/material_sub_heading' do %>
  Lähdekoodin kommentointi
<% end %>

<p>
  Lähdekoodiin voidaan lisätä kommentteja joko yhdelle riville kahden vinoviivan jälkeen <code>// kommentti</code> tai useammalle riville vinoviivan ja tähden sekä tähden ja vinoviivan rajaamalle alueelle <code>/* kommentti */</code>.
</p>


<% partial 'partials/code_highlight' do %>
  /*
  Tulostaa luvut kymmenestä yhteen. Jokainen
  luku tulostetaan omalle rivilleen.
  */
  int luku = 10;
  while (luku &gt; 0) {
      System.out.println(luku);
      luku--; // sama kuin luku = luku - 1;
  }
<% end %>


<p>
  Kommenteilla on useita käyttötarkoituksia. Ohjelmointikurssilla ohjelmointia opettelevan kannattaa käyttää kommentteja ohjelman toiminnallisuuden itselleen selittämiseen. Kun yllä oleva lähdekoodi on selitetty kommenteissa rivi riviltä auki, näyttää se esimerkiksi seuraavalta.
</p>

<% partial 'partials/code_highlight' do %>
  /*
  Tulostaa luvut kymmenestä yhteen. Jokainen
  luku tulostetaan omalle rivilleen.
  */

  // Luodaan kokonaislukutyyppinen muuttuja nimeltä
  // luku, johon asetetaan arvo 10.
  int luku = 10;

  // Toistolauseen lohkon suoritusta jatketaan kunnes
  // muuttujan luku arvo on nolla tai pienempi kuin nolla.
  // Suoritus ei lopu _heti_ kun muuttujaan luku asetetaan
  // arvo nolla, vaan vasta kun toistolauseen ehtolauseke
  // evaluoidaan seuraavan kerran. Tämä tapahtuu aina lohkon
  // suorituksen jälkeen.
  while (luku &gt; 0) {
      // tulostetaan muuttujassa luku oleva arvo sekä rivinvaihto
      System.out.println(luku);
      // vähennetään yksi luku-muuttujan arvosta
      luku--; // sama kuin luku = luku - 1;
  }
<% end %>

<p>
  Kommentit eivät vaikuta ohjelman suoritukseen, eli ohjelma toimii kommenttien kanssa täysin samalla tavalla kuin ilman kommentteja.
</p>

<p>
  Edellä käytetty ohjelmoinnin opetteluun tarkoitettu kommentointityyli on kuitenkin ohjelmistokehitykseen kelpaamaton. Ohjelmistoja rakennettaessa <strong>lähdekoodin tulee kommentoida itse itsensä</strong>. Tällöin ohjelman toiminnallisuus tulee ilmi luokkien, metodien ja muuttujien nimistä.
</p>

<p>
  Edelliset esimerkit voidaan yhtä hyvin kommentoida kapseloimalla ohjelmakoodi sopivasti nimettyn metodin sisään. Alla on kaksi esimerkkiä yllä olevan koodin kapseloivista metodeista -- toinen metodeista on hieman yleiskäyttöisempi kuin toinen. Toisaalta, jälkimmäisessä metodissa oletetaan, että käyttäjä tietää kumpaan parametreista asetetaan isompi ja kumpaan pienempi luku.
</p>

<% partial 'partials/code_highlight' do %>
  public void tulostaLuvutKymmenestaYhteen() {
      int luku = 10;
      while (luku &gt; 0) {
          System.out.println(luku);
          luku--;
      }
  }
<% end %>

<% partial 'partials/code_highlight' do %>
  public void tulostaLuvutIsoimmastaPienimpaan(int mista, int mihin) {
      while (mista &gt;= mihin) {
          System.out.println(mista);
          mista--;
      }
  }
<% end %>

<% partial 'partials/material_sub_heading' do %>
  Kommenteista ja ymmärrettävyydestä
<% end %>

<p>
  Alla on hieman kryptisempi ohjelma.
</p>

<p>
  Tutustu ohjelmaan ja yritä selvittää mitä ohjelma tekee ennen materiaalissa etenemistä. Alla olevan ohjelman suorituksen selvittämisessä kannattaa käyttää esimerkiksi kynää ja paperia. Kun käytössäsi on kynä ja paperi, aloita ohjelmakoodin läpi käyminen rivi riviltä kuin olisit tietokone. Kirjaa jokaisen rivin jälkeen ylös ohjelman käyttämissä muuttujissa tapahtuneet muutokset.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Integer&gt; l = new ArrayList&lt;&gt;();
  l.add(12);
  l.add(14);
  l.add(18);
  l.add(40);
  l.add(41);
  l.add(42);
  l.add(47);
  l.add(52);
  l.add(59);
  int x = 42;

  int a = 0;
  int b = l.size() - 1;
  while (a &lt;= b) {
      int c = a + (b - a) / 2;
      if (x &lt; l.get(c)) {
          b = c - 1;
      } else if (x &gt; l.get(c)) {
          a = c + 1;
      } else {
          System.out.println(c);
      }
  }

  System.out.println("-1");
<% end %>

<p>
  Kun olet kokeillut ohjelman toiminnan seuraamista yllä olevalla ohjelmalla, toista harjoitus alla olevalla ohjelmalla. Alla olevassa ohjelmassa muuttujien nimet on muutettu kuvaavammiksi.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
  luvut.add(12);
  luvut.add(14);
  luvut.add(18);
  luvut.add(40);
  luvut.add(41);
  luvut.add(42);
  luvut.add(47);
  luvut.add(52);
  luvut.add(59);

  int haettava = 42;

  int alaraja = 0;
  int ylaraja = luvut.size() - 1;
  while (alaraja &lt;= ylaraja) {
      int keskikohta = alaraja + (ylaraja - alaraja) / 2;
      if (haettava &lt; luvut.get(keskikohta)) {
          ylaraja = keskikohta - 1;
      } else if (haettava &gt; luvut.get(keskikohta)) {
          alaraja = keskikohta + 1;
      } else {
          System.out.println(keskikohta);
      }
  }

  System.out.println("-1");
<% end %>

<p>
  Lähdekoodi, missä muuttujien nimet on selkeitä, on helpommin ymmärrettävää kuin lähdekoodi, missä muuttujien nimet eivät kuvaa niiden tarkoitusta. Haluamme ohjelmasta version, joka on nopeasti ymmärrettävissä. Luodaan siitä metodi ja nimetään metodi sopivasti.
</p>

<% partial 'partials/code_highlight' do %>
  public int binaariHaku(ArrayList&lt;Integer&gt; luvut, int haettava) {

      int alaraja = 0;
      int ylaraja = luvut.size() - 1;
      while (alaraja &lt;= ylaraja) {
          int keskikohta = alaraja + (ylaraja - alaraja) / 2;
          if (haettava &lt; luvut.get(keskikohta)) {
              ylaraja = keskikohta - 1;
          } else if (haettava &gt; luvut.get(keskikohta)) {
              alaraja = keskikohta + 1;
          } else {
              return keskikohta;
          }
      }

      return -1;
  }
<% end %>

<p>
  Lähdekoodi on nyt ymmärrettävissä suoraan metodin määrittelystä: <code>public void binaariHaku(ArrayList&lt;Integer&gt; luvut, int haettava)</code>. Kyseessä on binäärihakualgoritmi, joka etsii listasta annettua lukua. Metodimäärittely ei kuitenkaan kerro binäärihakuun liittyvistä oletuksista tai sen palautusarvoista.
</p>

<p>
  Korjataan tilanne kommentilla. Yllä esitetyn binäärihakualgoritmin toiminnan ehtona on se, että lista on järjestyksessä pienimmästä suurimpaan. Jos etsittävä luku löytyy, algoritmi palauttaa luvun indeksin. Jos lukua taas ei löydy, algoritmi palauttaa luvun -1.
</p>

<p>
  Käytämme alla ohjelman dokumentointiin liittyvää kommentointitapaa, missä kommentti alkaa vinoviivalla ja kahdella tähdellä sekä päättyy yhteen tähteen ja vinoviivaan <code>/** kommentti */</code>. Ohjelmointiympäristöt näyttävät metodeihin liittyvät dokumenttikommentit muunmuassa lähdekoodin automaattisen täydennyksen yhteydessä.
</p>

<% partial 'partials/code_highlight' do %>
  /**
  Binäärihaku etsii parametrina annetusta listasta parametrina annettua lukua.
  Jos etsittävä luku löytyy, metodi palauttaa luvun indeksin listassa. Jos
  etsittävää lukua ei löydy, metodi palauttaa arvon -1. Metodi olettaa, että
  lista on järjestetty pienimmästä arvosta suurimpaan.
  */

  public int binaariHaku(ArrayList&lt;Integer&gt; luvut, int haettava) {

      int alaraja = 0;
      int ylaraja = luvut.size() - 1;
      while (alaraja &lt;= ylaraja) {
          int keskikohta = alaraja + (ylaraja - alaraja) / 2;
          if (haettava &lt; luvut.get(keskikohta)) {
              ylaraja = keskikohta - 1;
          } else if (haettava &gt; luvut.get(keskikohta)) {
              alaraja = keskikohta + 1;
          } else {
              return keskikohta;
          }
      }

      return -1;
  }
<% end %>

<p>
  Alla olevassa kuvassa näytetään miten ohjelmointiympäristö näyttää metodiin liittyvän kommentin. Oletuksena on, että hakualgoritmi on luokassa Hakualgoritmit. Kun luokasta on tehty olio, ja ohjelmoija alkaa kirjoittamaan metodin nimeä, näyttää ohjelmointiympäristö metodiin aiemmin liitetyn dokumentaation. Kuvassa metodin parametrien määrittely poikkeaa hieman edellisestä esimerkistä.
</p>

<img src="/img/material/autocomplete-with-comment.png" alt="Ohjelmointiympäristö näyttää metodiin liitetyn kommentin."/>

<p>
  &nbsp;
</p>

<p>
  Kommentteja käytetään siis ensisijaisesti luokkien sekä metodien yleisen toiminnallisuuden kuvaamisessa sen sijaan, että kerrottaisiin yksityiskohtaisesti mitä ohjelma tekee. Yksityiskohtainen ohjelman toiminnan avaaminen on kuitenkin hyvä tapa selittää ohjelmakoodia itselleen. Yleisesti ottaen voidaan ajatella niin, että vaikeasti ymmärrettävät ohjelmat kannattaa pilkkoa luokkiin ja metodeihin, jotka kuvaavat ohjelman rakennetta. Dokumentointi ja kommentointi niiltä osin, mitkä eivät ole luokkien tai metodien nimistä selviä, on tärkeää -- esimerkiksi metodien paluuarvot sekä niiden toimintaan liittyvät oletukset on hyvä dokumentoida.
</p>


<% partial 'partials/material_sub_heading' do %>
  Sovellus ja sen osat
<% end %>

<p>
  Edellä puhuimme kommenteista sekä ohjelman pilkkomisesta luokkiin ja metodeihin, jotka kuvaavat ohjelman rakennetta. Seuraava katkelma on <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra" target="_blank" rel="noopener">Edsger W. Dijkstran</a> artikkelista <a href="https://www.cs.utexas.edu/users/EWD/ewd04xx/EWD447.PDF" target="_blank" rel="noopener">On the role of scientific thought</a>.
</p>

<p>
  <em>
    Let me try to explain to you, what to my taste is characteristic for all intelligent thinking. It is, that one is willing to study in depth an aspect of one's subject matter in isolation for the sake of its own consistency, all the time knowing that one is occupying oneself only with one of the aspects. We know that a program must be correct and we can study it from that viewpoint only; we also know that it should be efficient and we can study its efficiency on another day, so to speak. In another mood we may ask ourselves whether, and if so: why, the program is desirable. But nothing is gained - on the contrary! - by tackling these various aspects simultaneously. It is what I sometimes have called "<strong>the separation of concerns</strong>", which, even if not perfectly possible, is yet the only available technique for effective ordering of one's thoughts, that I know of. This is what I mean by "focusing one's attention upon some aspect": it does not mean ignoring the other aspects, it is just doing justice to the fact that from this aspect's point of view, the other is irrelevant. It is being one- and multiple-track minded simultaneously.
  </em>
</p>

<p>
  Ohjelmoijan tulee pystyä tarkastelemaan ohjelmaansa eri näkökulmista ilman, että muut ohjelman osa-alueet vievät keskittymistä. Käyttöliittymään tulee voida keskittyä ilman, että ohjelmoijan tulee keskittyä sovelluksen ydinlogiikkaan. Vastaavasti ohjelmassa ja ongelma-alueessa esiintyviin käsitteisiin tulee voida keskittyä ilman, että ohjelmoijan tarvitsee välittää käyttöliittymästä. Vastaavasti ohjelmassa käytettävien algoritmien tehokkuus on oma "huolenaihe", johon ohjelmoijan tulee voida keskittyä ilman huolta muista osa-alueista.
</p>

<p>
  Samaa ajatusta voidaan jatkaa vastuiden näkökulmasta. Robert "Uncle Bob" C. Martin kuvaa <a href="https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" target="_blank" rel="noopener">blogissaan</a> termiä "<strong>single responsibility principle</strong>" seuraavasti.
</p>


<p>
  <em>
    When you write a software module, you want to make sure that when changes are requested, those changes can only originate from a single person, or rather, a single tightly coupled group of people representing a single narrowly defined business function. You want to isolate your modules from the complexities of the organization as a whole, and design your systems such that each module is responsible (responds to) the needs of just that one business function.
  </em>
</p>

<p>
  <em>
    [..in other words..] Gather together the things that change for the same reasons. Separate those things that change for different reasons.
  </em>
</p>


<p>
  Selkeys saadaan aikaan sopivalla luokkarakenteella sekä nimeämiskäytänteiden seuraamisella. Jokaisella luokalla tulee olla vastuu, johon liittyviä tehtäviä luokka hoitaa. Metodeja käytetään toiston vähentämiseen ja luokkien sisäisten toimintojen jäsentämiseen. Myös metodeilla tulee olla selkeä vastuu eli metodien ei tule olla liian pitkiä ja liian montaa asiaa tekeviä. Liian montaa asiaa tekevät monimutkaiset metodit tuleekin pilkkoa useiksi pienemmiksi apumetodeiksi joita alkuperäinen metodi kutsuu.
</p>



<% partial 'partials/hint', locals: { name: 'Hyvin harva ohjelma kirjoitetaan vain kerran' } do %>

  <p>
    Ohjelmistoja kehittäessä keskitytään tyypillisesti niihin ohjelmiston ominaisuuksiin, jotka tuovat eniten arvoa ohjelmiston käyttäjälle. Nämä ominaisuudet sovitaan yhdessä ohjelmiston kehittäjän sekä loppukäyttäjän kanssa, mikä mahdollistaa ominaisuuksien järjestämisen tärkeysjärjestykseen.
  </p>

  <p>
    Ohjelmistoille on tyypillistä se, että ohjelmistoon liittyvät toiveet sekä ominaisuuksien tärkeysjärjestys muuttuu ohjelmiston elinkaaren aikana. Tämä johtaa siihen, että osia ohjelmistosta kirjoitetaan uudestaan, osia siirrellään paikasta toiseen ja osia poistetaan kokonaan.
  </p>

  <p>
    Ohjelmoijan näkökulmasta tämä tarkoittaa ensisijaisesti sitä, että ohjelmisto kehittyy jatkuvasti. Uudelleenkirjoitettavat osat tulevat tyypillisesti paremmiksi, sillä ohjelmoija oppii ongelma-alueesta siihen liittyviä ratkaisuja kehittäessään. Samalla tämä tarkoittaa sitä, että ohjelmoijan tulee myös säilyttää kokonaiskuva ohjelman rakenteesta, sillä joitain osia saatetaan myös uudelleenkäyttää muissa osissa ohjelmistoa.
  </p>

  <p>
    Yleisesti ottaen voidaan todeta, että hyvin harva ohjelma kirjoitetaan vain kerran. Tätä ajatusta jatkaen on hyvä pyrkiä tilanteeseen, missä ohjelman käyttäjä pääsee kokeilemaan sitä mahdollisimman nopeasti -- tällöin muutostoiveiden kerääminen myös alkaa nopeasti. Ohjelmistoja tehdessä onkin hyvä usein luoda ensin <a href="https://en.wikipedia.org/wiki/Proof_of_concept" target="_blank" rel="noopener">Proof of Concept</a>-sovellus, jolla voidaan kokeilla idean toimivuutta. Jos idea on hyvä, sitä jatkokehitetään -- samalla myös ohjelma ja kehittyy.
  </p>

<% end %>



<% partial 'partials/material_heading' do %>
  Ongelmasta kokonaisuuteen ja takaisin osiin
<% end %>

<p>
  Tarkastellaan erään ohjelman rakennusprosessia sekä tutustutaan sovelluksen vastuualueiden erottamiseen toisistaan. Ohjelma kysyy käyttäjältä sanoja kunnes käyttäjä syöttää saman sanan uudestaan. Ohjelma käyttää listaa sanojen tallentamiseen.
</p>

<% partial 'partials/sample_output' do %>
  Anna sana: <font color="red">porkkana</font>
  Anna sana: <font color="red">selleri</font>
  Anna sana: <font color="red">nauris</font>
  Anna sana: <font color="red">lanttu</font>
  Anna sana: <font color="red">selleri</font>
  Annoit saman sanan uudestaan!
<% end %>

<p>
  Rakennetaan ohjelma osissa. Eräs haasteista on se, että on vaikea päättää miten lähestyä tehtävää, eli miten ongelma tulisi jäsentää osaongelmiksi, ja mistä osaongelmasta kannattaisi aloittaa. Yhtä oikeaa vastausta ei ole -- joskus on hyvä lähteä pohtimaan ongelmaan liittyviä käsitteitä ja niiden yhteyksiä, joskus taas ohjelman tarjoamaa käyttöliittymää.
</p>

<p>
  Käyttöliittymän hahmottelu voisi lähteä liikenteeseen luokasta Kayttoliittyma. Käyttöliittymä käyttää Scanner-oliota, jonka sille voi antaa. Tämän lisäksi käyttöliittymällä on käynnistämiseen tarkoitettu metodi.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;

      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
      }

      public void kaynnista() {
          // tehdään jotain
      }
  }
<% end %>

<p>
  Käyttöliittymän luominen ja käynnistäminen onnistuu seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
      Scanner lukija = new Scanner(System.in);
      Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija);
      kayttoliittyma.kaynnista();
  }
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Toisto ja lopetus
<% end %>

<p>
  Ohjelmassa on (ainakin) kaksi "aliongelmaa". Ensimmäinen on sanojen toistuva lukeminen käyttäjältä kunnes tietty ehto toteutuu. Tämä voitaisiin hahmotella seuraavaan tapaan.
</p>


<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;

      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
      }

      public void kaynnista() {

          while (true) {
              System.out.print("Anna sana: ");
              String sana = lukija.nextLine();

              if (<em>pitää lopettaa</em>) {
                  break;
              }

          }

          System.out.println("Annoit saman sanan uudestaan!");
      }
  }
<% end %>

<p>
  Sanojen kysely jatkuu kunnes käyttäjä syöttää jo aiemmin syötetyn sanan. Täydennetään ohjelmaa siten, että se tarkastaa onko sana jo syötetty. Vielä ei tiedetä miten toiminnallisuus kannattaisi tehdä, joten tehdään siitä vasta runko.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;

      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
      }

      public void kaynnista() {

          while (true) {
              System.out.print("Anna sana: ");
              String sana = lukija.nextLine();

              if (onJoSyotetty(sana)) {
                  break;
              }

          }

          System.out.println("Annoit saman sanan uudestaan!");
      }

      public boolean onJoSyotetty(String sana) {
          // tänne jotain

          return false;
      }
  }
<% end %>

<p>
  Ohjelmaa on hyvä testata koko ajan, joten tehdään metodista kokeiluversio:
</p>

<% partial 'partials/code_highlight' do %>
  public boolean onJoSyotetty(String sana) {
      if (sana.equals("loppu")) {
          return true;
      }

      return false;
  }
<% end %>

<p>
  Nyt toisto jatkuu niin kauan kunnes syötteenä on sana loppu:
</p>

<% partial 'partials/sample_output' do %>
  Anna sana: <span class="red">porkkana</span>
  Anna sana: <span class="red">selleri</span>
  Anna sana: <span class="red">nauris</span>
  Anna sana: <span class="red">lanttu</span>
  Anna sana: <span class="red">loppu</span>
  Annoit saman sanan uudestaan!
<% end %>

<p>
  Ohjelma ei toimi vielä kokonaisuudessaan, mutta ensimmäinen osaongelma eli ohjelman pysäyttäminen kunnes tietty ehto toteutuu on saatu toimimaan.
</p>

<% partial 'partials/material_sub_heading' do %>
  Oleellisten tietojen tallentaminen
<% end %>

<p>
  Toinen osaongelma on aiemmin syötettyjen sanojen muistaminen. Lista sopii mainiosti tähän tarkoitukseen.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;
      private ArrayList&lt;String&gt; aiemmatSanat;
   
      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
          this.aiemmatSanat = new ArrayList&lt;String&gt;();
      }

      //...
<% end %>

<p>
  Kun uusi sana syötetään, on se lisättävä syötettyjen sanojen joukkoon. Tämä tapahtuu lisäämällä while-silmukkaan listan sisältöä päivittävä rivi:
</p>

<% partial 'partials/code_highlight' do %>
  while (true) {
      System.out.print("Anna sana: ");
      String sana = lukija.nextLine();

      if (onJoSyotetty(sana)) {
          break;
      }

      // lisätään uusi sana aiempien sanojen listaan
      this.aiemmatSanat.add(sana);
  }
<% end %>

<p>
  Kayttoliittyma näyttää kokonaisuudessaan seuraavalta.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;
      private ArrayList&lt;String&gt; aiemmatSanat;
  
      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
          this.aiemmatSanat = new ArrayList&lt;String&gt;();
      }

      public void kaynnista() {

          while (true) {
              System.out.print("Anna sana: ");
              String sana = lukija.nextLine();

              if (onJoSyotetty(sana)) {
                  break;
              }

              // lisätään uusi sana aiempien sanojen listaan
              this.aiemmatSanat.add(sana);
          }

          System.out.println("Annoit saman sanan uudestaan!");
      }

      public boolean onJoSyotetty(String sana) {
          if (sana.equals("loppu")) {
              return true;
          }

          return false;
      }
  }
<% end %>

<p>
  Jälleen kannattaa testata, että ohjelma toimii edelleen. Voi olla hyödyksi esimerkiksi lisätä kaynnista-metodin loppuun testitulostus, joka varmistaa että syötetyt sanat todella menivät listaan.
</p>

<% partial 'partials/code_highlight' do %>
  // testitulostus joka varmistaa että kaikki toimii edelleen
  this.aiemmatSanat.stream().forEach(s -&gt; System.out.println(s));
<% end %>

<% partial 'partials/material_sub_heading' do %>
  Osaongelmien ratkaisujen yhdistäminen
<% end %>

<p>
  Muokataan vielä äsken tekemämme metodi <code>onJoSyotetty</code> tutkimaan onko kysytty sana jo syötettyjen joukossa, eli listassa.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean onJoSyotetty(String sana) {
      return this.aiemmatSanat.contains(sana);
  }
<% end %>

<p>
  Nyt sovellus toimii kutakuinkin halutusti.
</p>

<% partial 'partials/material_sub_heading' do %>
  Oliot luonnollisena osana ongelmanratkaisua
<% end %>

<p>
  Rakensimme äsken ratkaisun ongelmaan, missä luetaan käyttäjältä sanoja, kunnes käyttäjä antaa saman sanan uudestaan. Syöte ohjelmalle oli esimerkiksi seuraavanlainen.
</p>

<% partial 'partials/sample_output' do %>
  Anna sana: <span class="red">porkkana</span>
  Anna sana: <span class="red">selleri</span>
  Anna sana: <span class="red">nauris</span>
  Anna sana: <span class="red">lanttu</span>
  Anna sana: <span class="red">selleri</span>
  Annoit saman sanan uudestaan!
<% end %>

<p>
  Päädyimme ratkaisuun
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;
      private ArrayList&lt;String&gt; aiemmatSanat;
  
      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
          this.aiemmatSanat = new ArrayList&lt;String&gt;();
      }

      public void kaynnista() {

          while (true) {
              System.out.print("Anna sana: ");
              String sana = lukija.nextLine();

              if (onJoSyotetty(sana)) {
                  break;
              }

              // lisätään uusi sana aiempien sanojen listaan
              aiemmatSanat.add(sana);
          }

          System.out.println("Annoit saman sanan uudestaan!");
      }

      public boolean onJoSyotetty(String sana) {
          return this.aiemmatSanat.contains(sana);
      }
  }
<% end %>

<p>
  Ohjelman käyttämä apumuuttuja lista <code>aiemmatSanat</code> on yksityiskohta käyttöliittymän kannalta. Käyttöliittymän kannaltahan on oleellista, että muistetaan niiden <em>sanojen joukko</em> jotka on nähty jo aiemmin. Sanojen joukko on selkeä erillinen "käsite", tai abstraktio. Tälläiset selkeät käsitteet ovat potentiaalisia olioita; kun koodissa huomataan "käsite" voi sen eristämistä erilliseksi luokaksi harkita.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Sanajoukko
<% end %>

<p>
  Tehdään luokka <code>Sanajoukko</code>, jonka käyttöönoton jälkeen käyttöliittymän metodi <code>kaynnista</code> on seuraavanlainen:
</p>

<% partial 'partials/code_highlight' do %>
  while (true) {
      String sana = lukija.nextLine();

      if (aiemmatSanat.sisaltaa(sana)) {
          break;
      }

      aiemmatSanat.lisaa(sana);
  }

  System.out.println("Annoit saman sanan uudestaan!");
<% end %>

<p>
  Käyttöliittymän kannalta Sanajoukolla kannattaisi siis olla metodit <code>boolean sisaltaa(String sana)</code> jolla tarkastetaan sisältyykö annettu sana jo sanajoukkoon ja <code>void lisaa(String sana)</code> jolla annettu sana lisätään joukkoon.
</p>

<p>
  Huomaamme, että näin kirjoitettuna käyttöliittymän luettavuus on huomattavasti parempi.
</p>

<p>
  Luokan <code>Sanajoukko</code> runko näyttää seuraavanlaiselta:
</p>

<% partial 'partials/code_highlight' do %>
  public class Sanajoukko {
      // oliomuuttuja(t)

      public Sanajoukko() {
          // konstruktori
      }

      public boolean sisaltaa(String sana) {
          // sisältää-metodin toteutus
          return false;
      }

      public void lisaa(String sana) {
          // lisaa-metodin toteutus
      }
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Toteutus aiemmasta ratkaisusta
<% end %>

<p>
  Voimme toteuttaa sanajoukon siirtämällä aiemman ratkaisumme listan sanajoukon oliomuuttujaksi:
</p>

<% partial 'partials/code_highlight' do %>
  import java.util.ArrayList;
  
  public class Sanajoukko {
      private ArrayList&lt;String&gt; sanat;
      public Sanajoukko() {
          this.sanat = new ArrayList&lt;&gt;();
      }

      public void lisaa(String sana) {
          this.sanat.add(sana);
      }

      public boolean sisaltaa(String sana) {
          return this.sanat.contains(sana);
      }
  }
<% end %>


<p>
  Ratkaisu on nyt melko elegantti. Erillinen käsite on saatu erotettua ja käyttöliittymä näyttää siistiltä. Kaikki "likaiset yksityiskohdat" on saatu siivottua eli kapseloitua olion sisälle.
</p>

<p>
  Muokataan käyttöliittymää niin, että se käyttää Sanajoukkoa. Sanajoukko annetaan käyttöliittymälle samalla tavalla parametrina kuin Scanner.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;
      private Sanajoukko sanajoukko;

      public Kayttoliittyma(Scanner lukija, Sanajoukko sanajoukko) {
          this.lukija = lukija;
          this.sanajoukko = sanajoukko;
      }

      public void kaynnista() {

          while (true) {
              System.out.print("Anna sana: ");
              String sana = lukija.nextLine();

              if (this.sanajoukko.sisaltaa(sana)) {
                  break;
              }

              this.sanajoukko.lisaa(sana);
          }

          System.out.println("Annoit saman sanan uudestaan!");
      }
  }
<% end %>

<p>
  Ohjelman käynnistäminen tapahtuu nyt seuraavasti:
</p>


<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
      Scanner lukija = new Scanner(System.in);
      Sanajoukko joukko = new Sanajoukko();

      Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija, joukko);
      kayttoliittyma.kaynnista();
  }
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Luokan sisäisen toteutuksen muuttaminen
<% end %>

<p>
  Olemme päätyneet tilanteeseen missä <code>Sanajoukko</code> ainoastaan "kapseloi" ArrayList:in. Onko tässä järkeä? Kenties. Voimme nimittäin halutessamme tehdä Sanajoukolle muitakin muutoksia. Ennen pitkään saatamme esim. huomata, että sanajoukko pitää tallentaa tiedostoon. Jos tekisimme nämä muutokset Sanajoukkoon muuttamatta käyttöliittymän käyttävien metodien nimiä, ei käyttöliittymää tarvitsisi muuttaa mitenkään.
</p>

<p>
  Oleellista on tässä se, että Sanajoukko-luokkaan tehdyt sisäiset muutokset eivät vaikuta luokkaan Käyttöliittymä. Tämä johtuu siitä, että käyttöliittymä käyttää sanajoukkoa sen tarjoamien metodien -- eli julkisten rajapintojen -- kautta.
</p>

<% partial 'partials/material_sub_heading' do %>
  Uusien toiminnallisuuksien toteuttaminen: palindromit
<% end %>

<p>
  Voi olla, että jatkossa ohjelmaa halutaan laajentaa siten, että <code>Sanajoukko</code>-luokan olisi osattava uusia asiota. Jos ohjelmassa haluttaisiin esimerkiksi tietää kuinka moni syötetyistä sanoista oli palindromi, voidaan sanajoukkoa laajentaa metodilla <code>palindromeja</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public void kaynnista() {

      while (true) {
          System.out.print("Anna sana: ");
          String sana = lukija.nextLine();

          if (this.sanajoukko.sisaltaa(sana)) {
              break;
          }

          this.sanajoukko.lisaa(sana);
      }

      System.out.println("Annoit saman sanan uudestaan!");
      System.out.println("Sanoistasi " + this.sanajoukko.palindromeja() + " oli palindromeja");
  }
<% end %>

<p>
  Käyttöliittymä säilyy siistinä ja palindromien laskeminen jää <code>Sanajoukko</code>-olion huoleksi. Metodin toteutus voisi olla esimerkiksi seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
  import java.util.ArrayList;

  public class Sanajoukko {
      private ArrayList&lt;String&gt; sanat;

      public Sanajoukko() {
          this.sanat = new ArrayList&lt;&gt;();
      }

      public boolean sisaltaa(String sana) {
          return this.sanat.contains(sana);
      }

      public void lisaa(String sana) {
          this.sanat.add(sana);
      }

      public int palindromeja() {
          return (int) this.sanat.stream().filter(s -> onPalindromi(s)).count();
      }

      public boolean onPalindromi(String sana) {
          int loppu = sana.length() - 1;

          int i = 0;
          while (i &lt; sana.length() / 2) {
              // metodi charAt palauttaa annetussa indeksissä olevan merkin
              if(sana.charAt(i) != sana.charAt(loppu - i)) {
                  return false;
              }

              i++;
          }

          return true;
      }
  }
<% end %>

<p>
  Metodissa <code>palindromeja</code> käytetään sekä apumetodia <code>onPalindromi</code> että virran filter-metodia. Virran <code>count</code>-metodi palauttaa <code>long</code>-tyyppisen kokonaisluvun, joka tulee muuntaa int-tyyppiseksi ennen sen palautusta metodista.
</p>


<% partial 'partials/material_sub_heading' do %>
  Uusiokäyttö
<% end %>


<p>
  Kun ohjelmakoodin käsitteet on eriytetty omiksi luokikseen, voi niitä uusiokäyttää helposti muissa projekteissa. Esimerkiksi luokkaa <code>Sanajoukko</code> voisi käyttää yhtä hyvin graafisesta käyttöliittymästä, ja se voisi myös olla osa kännykässä olevaa sovellusta. Tämän lisäksi ohjelman toiminnan testaaminen on huomattavasti helpompaa silloin kun ohjelma on jaettu erillisiin käsitteisiin, joita kutakin voi käyttää myös omana itsenäisenä yksikkönään.
</p>


<% partial 'partials/material_sub_heading' do %>
  Neuvoja ohjelmointiin
<% end %>

<p>
  Yllä kuvatussa laajemmassa esimerkissä noudatettiin seuraavia neuvoja.
</p>

<ul>

  <li> Etene pieni askel kerrallaan
    <ul>
      <li> Yritä pilkkoa ongelma osaongelmiin ja <strong>ratkaise vain yksi osaongelma kerrallaan</strong> </li>
      <li> Testaa aina että ohjelma on etenemässä oikeaan suuntaan eli että osaongelman ratkaisu meni oikein</li>
      <li> Tunnista ehdot, minkä tapauksessa ohjelman tulee toimia eri tavalla. Esimerkiksi yllä tarkistus, jolla katsotaan onko sana jo syötetty, johtaa erilaiseen toiminnallisuuden.</li>
    </ul>
  </li>
  
  <li> Kirjoita mahdollisimman "siistiä" koodia
    <ul>
      <li> sisennä koodi </li>
      <li> käytä kuvaavia muuttujien ja metodien nimiä</li>
      <li> älä tee liian pitkiä metodeja, edes mainia</li>
      <li> tee yhdessä metodissa vaan yksi asia</li>
      <li> <strong>poista koodistasi kaikki copy-paste</strong></li>
      <li> korvaa koodisi "huonot" ja epäsiistit osat siistillä koodilla</li>
    </ul>
  </li>
  
  <li>
    Astu tarvittaessa askel taaksepäin ja mieti kokonaisuutta. Jos ohjelma ei toimi, voi olla hyvä idea palata aiemmin toimineeseen tilaan. Käänteisesti voidaan sanoa, että rikkinäinen ohjelma korjaantuu harvemmin lisäämällä siihen lisää koodia.
  </li>
  
</ul>

<p>
  Ohjelmoijat noudattavat näitä käytänteitä sen takia että ohjelmointi olisi helpompaa. Käytänteiden noudattaminen tekee myös ohjelmien lukemisesta, ylläpitämisestä ja muokkaamisesta helpompaa muille. 
</p>



<% partial 'partials/exercise', locals: { name: 'Sanakirja (5 osaa)' } do %>

  <p>
    Tässä tehtäväsarjassa toteutetaan sanakirja, josta voi hakea suomen kielen sanoille englanninkielisiä käännöksiä. Sanakirjan tekemisessä käytetään <code>HashMap</code>-tietorakennetta.
  </p>

  <h2>Luokka Sanakirja</h2>

  <p>
    Toteuta luokka nimeltä <code>Sanakirja</code>. Luokalla on aluksi seuraavat metodit:
  </p>

  <ul>
    <li> <code>public String kaanna(String sana)</code> metodi palauttaa parametrinsa käännöksen. Jos sanaa ei tunneta, palautetaan <em>null</em>.</li>
    <li> <code>public void lisaa(String sana, String kaannos)</code> metodi lisää sanakirjaan uuden käännöksen</li>
  </ul>

  <p>
    Toteuta luokka Sanakirja siten, että sen ainoa oliomuuttuja on <code>HashMap</code>-tietorakenne.
  </p>

  <p>
    Testaa sanakirjasi toimintaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("cembalo", "harpsichord");

    System.out.println(sanakirja.kaanna("apina"));
    System.out.println(sanakirja.kaanna("porkkana"));
  <% end %>

  <% partial 'partials/sample_output' do %>
    monkey
    null
  <% end %>


  <h2>Sanojen lukumäärä</h2>

  <p>
    Lisää sanakirjaan metodi <code>public int sanojenLukumaara()</code>, joka palauttaa sanakirjassa olevien sanojen lukumäärän.
  </p>

  <% partial 'partials/code_highlight' do %>
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    System.out.println(sanakirja.sanojenLukumaara());

    sanakirja.lisaa("cembalo", "harpsichord");
    System.out.println(sanakirja.sanojenLukumaara());
  <% end %>


  <% partial 'partials/sample_output' do %>
    2
    3
  <% end %>

  <p>
    Tässä osassa kannattaa tutkiskella HashMapin valmiiksi tarjoamia metodeja... Vaihtoehtoisesti <code>long</code>-tyyppisen muuttujan saa muunnettua <code>int</code>-tyyppiseksi seuraavalla tavalla.
  </p>

  <% partial 'partials/code_highlight' do %>
    long lukuLongina = 1L;
    int lukuInttina = (int) lukuLongina;
  <% end %>


  <h2>Kaikkien sanojen listaaminen</h2>

  <p>
    Lisää sanakirjaan metodi <code>public ArrayList&lt;String&gt; kaannoksetListana()</code> joka palauttaa sanakirjan sisällön listana <i>avain = arvo</i> muotoisia merkkijonoja.
  </p>

  <% partial 'partials/code_highlight' do %>
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("cembalo", "harpsichord");

    ArrayList&lt;String&gt; kaannokset = sanakirja.kaannoksetListana();
    kaannokset.stream().forEach(k -&gt; System.out.println(k));
  <% end %>

  <% partial 'partials/sample_output' do %>
    banaani = banana
    apina = monkey
    cembalo = harpsichord
  <% end %>


  <h2>Tekstikäyttöliittymän alku</h2>

  <p>
    Harjoitellaan erillisen tekstikäyttöliittymän tekemistä. Luo luokka <code>Tekstikayttoliittyma</code>, jolla on seuraavat metodit:
  </p>

  <ul>
    <li> konstruktori <code>public Tekstikayttoliittyma(Scanner lukija, Sanakirja sanakirja)</code></li>
    <li> metodi <code>public void kaynnista()</code>, joka käynnistää tekstikäyttöliittymän.</li>
  </ul>

  <p>
    Tekstikäyttöliittymä tallettaa konstruktorin parametrina saamansa lukijan ja sanakirjan oliomuuttujiin. Muita oliomuuttujia ei tarvita. <strong>Käyttäjän syötteen lukeminen tulee hoitaa konstruktorin parametrina saatua lukija-olioa käyttäen! Myös kaikki käännökset on talletettava konstruktorin parametrina saatuun sanakirja-olioon. Tekstikäyttöliittymä ei saa luoda Scanneria tai Sanakirjaa itse!</strong>
  </p>

  <p>
    <strong>HUOM:</strong> vielä uudelleen edellinen, eli <strong>Tekstikäyttöliittymä ei saa luoda itse skanneria</strong> vaan sen on käytettävä parametrina saamaansa skanneria syötteiden lukemiseen!
  </p>

  <p>
    Tekstikäyttöliittymässä tulee aluksi olla vain komento <code>lopeta</code>, joka poistuu tekstikäyttöliittymästä. Jos käyttäjä syöttää jotain muuta, käyttäjälle sanotaan "Tuntematon komento".
  </p>

  <% partial 'partials/code_highlight' do %>
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
  <% end %>

  <% partial 'partials/sample_output' do %>
    Komennot:
    lopeta - poistuu käyttöliittymästä

    Komento: <font color="red">apua</font>
    Tuntematon komento.

    Komento: <font color="red">lopeta</font>
    Hei hei!
  <% end %>

  <h2>Sanojen lisääminen ja kääntäminen</h2>

  <p>
    Lisää tekstikäyttöliittymälle komennot <code>lisaa</code> ja <code>kaanna</code>. Komento <code>lisaa</code> lisää kysyy käyttäjältä sanaparin ja lisää sen sanakirjaan. Komento <code>kaanna</code> kysyy käyttäjältä sanaa ja tulostaa sen käännöksen.
  </p>

  <% partial 'partials/code_highlight' do %>
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
  <% end %>

  <% partial 'partials/sample_output' do %>
    Komennot:
    lisaa - lisää sanaparin sanakirjaan
    kaanna - kysyy sanan ja tulostaa sen käännöksen
    lopeta - poistuu käyttöliittymästä

    Komento: <font color="red">lisaa</font>
    Suomeksi: <font color="red">porkkana</font>
    Käännös: <font color="red">carrot</font>

    Komento: <font color="red">kaanna</font>
    Anna sana: <font color="red">porkkana</font>
    Käännös: carrot

    Komento: <font color="red">lopeta</font>
    Hei hei!
  <% end %>

<% end %>


<%= partial 'partials/quiz', locals: { id: '59da57ee4538e90004e0f0e3' } %>
